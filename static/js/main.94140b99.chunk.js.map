{"version":3,"sources":["modules/leibniz-parser.ts","react/SceneComponent.tsx","react/ExprField.tsx","react/OptionPanel.tsx","react/DefsPanel.tsx","react/BodyRow.tsx","react/BodiesPane.tsx","react/Editor.tsx","react/ImportFile.tsx","modules/leibniz-tensor.ts","modules/leibnitz-dumper.ts","react/DumpPanel.tsx","modules/leibniz-renderer.ts","react/LbNavBar.tsx","react/LbAlert.tsx","modules/leibniz-defs.ts","modules/leibnitz-codegen.ts","modules/leibniz-code.ts","modules/leibniz-compiler.ts","App.tsx","reportWebVitals.js","index.js"],"names":["TokenType","ASTNodeType","BabylonScene","props","onResizeWindow","engine","state","resize","window","addEventListener","this","removeEventListener","canvas","onSceneMount","Engine","deterministicLockstep","lockstepMaxSteps","scene","Scene","setState","className","canvasClass","ref","c","onCanvasLoaded","Component","ExprField","name","expr","errors","withoutDelete","onDelete","onChange","hasErrors","length","errorItems","map","text","idx","deleteBtn","InputGroup","Append","Button","variant","onClick","icon","faTrash","Form","Group","size","Prepend","Control","type","value","ev","target","isValid","isInvalid","Feedback","OptionPanel","show","title","message","confirmButton","onCancel","onConfirm","Modal","onHide","Header","closeButton","Title","Body","Footer","Lexer","require","IdentifierRegex","NumberRegex","ExpNumberRegex","SingleIdentifierRegex","BaseVectorRegex","KroneckerRegex","Keywords","baseVectorId","m","exec","undefined","kroneckerId","toTokens","Error","lexer","addRule","lexeme","Number","Id","Symbol","tokens","input","r","lex","push","isIdentifier","tok","endAST","node","End","children","createIdAST","id","createNumberAST","createSeqAST","rule","Rule","createRepeatAST","DefaultASTNode","SyntaxParserContext","rules","current","_tokens","_current","_errors","_node","_rules","error","pos","token","withErrors","_","concat","keywordExpr","keyword","ctx","addError","next","withNode","symbolExpr","symbol","isSymbol","Sym","createSymbolAST","nonTermExpr","seqExpr","seq","nodes","ctx1","i","ctx2","altExpr","alts","repeatExpr","systemSyntax","isNumber","parse","expression","syntax","buildSyntaxParserContext","ast","ns","uuidv5","URL","DefsPanel","deleteModalShown","newName","panelKey","defs","newConf","clone","showOptionPanel","deleteDefs","action","modalTitle","modalMessage","optionAction","omit","hideOptionPanel","match","indexOf","identifierError","newNameError","fieldList","toPairs","sortBy","ary","key","hasNewNameError","Accordion","defaultActiveKey","Card","Toggle","as","eventKey","Collapse","controlId","onName","onAdd","disabled","faPlus","BodyRow","modalShown","body","position","rotation","rotField","onChangeRotation","deleteRotation","onAddRotation","onChangePosition","onDeleteRow","BodiesPanel","confirmAction","bodies","createBodies","deleteBody","splice","b","rows","Table","striped","scope","Editor","newDefs","noValidate","onBodiesChange","funcs","panelId","initialStatus","transition","ImportFile","file","onFileRead","onError","fr","FileReader","onload","e","result","onerror","event","console","toString","readAsText","File","label","custom","onFileChange","files","assert","condition","Matrix","values","_values","j","range","cols","get","join","row","f","n","Math","min","trace","a","other","zipMap","add","subtract","scale","partRows","take","col","appendRows","l","sum","k","sqrt","dot","module","divide","x","y","z","len","Quaternion","RotationAxis","Vector3","phi","sin","cos","theta","rr","sint","cost","sinp","cosp","sincos","sinsin","enchelon","gaussJordan","drop","det","mtx","Array","h","imax","max","abs","mx","tr","flatten","NEGATIVE_INFINITY","POSITIVE_INFINITY","flatMap","isQuaternion","w","isMatrix","vector","transpose","matrix","toCsv","data","sys","ks","keys","sort","hs","headers","sfx","hb","header","dataRows","status","rs","rb","p","CameraType","DumpPanel","counts","dt","dtString","countsString","dumpData","st","states","generateData","parseFloat","parseInt","blob","Blob","saveAs","dumpDisabled","Container","Row","inline","Label","placeholder","setCounts","setDt","LbNavBar","onReset","onLoad","onImport","onExport","Navbar","bg","expand","Brand","href","aria-controls","Nav","Link","process","NavDropdown","Item","onSelect","LbAlert","isVisible","onClose","Alert","dismissible","Heading","CurrentSysDefVersion","fromHeat","s","hc","Color3","Red","White","fromHSB","ValueTypeCode","Leibniz","_props","_maxDt","_status","_shapes","_remainderT","color","mesh","material","StandardMaterial","ambientColor","diffuseColor","shape","MeshBuilder","CreatePolyhedron","sizeX","sizeY","sizeZ","createOcta","sphere","CreateIcoSphere","flat","radius","subdivisions","updatable","createSphere","updateShape","options","_options","assign","cameraType","DeviceOrientation","cameraPosition","cameraMinZ","sunLightDirection","sunLightIntensity","maxDt","camera","DeviceOrientationCamera","setTarget","Zero","angularSensibility","Anaglyph","AnaglyphArcRotateCamera","PI","setPosition","VRDeviceOrientation","VRDeviceOrientationArcRotateCamera","ArcRotate","ArcRotateCamera","wheelPrecision","UniversalCamera","inputs","addMouseWheel","createCamera","attachControl","HemisphericLight","intensity","onBeforeStepObservable","realDt","getAnimationRatio","t","runRenderLoop","refreshScene","render","shapes","zip","forEach","rotationQuaternion","each","removeMesh","createShapes","tracing","createConstantCode","createMatrixRefCode","createNegMatrixCode","base","negate","createTransposeCode","createMulSQCode","av","bv","createMulSMCode","createMulMMCode","multiply","createDivMSCode","createAddSQCode","Identity","createAddMMCode","createSubMMCode","createAppendCode","append","createResizeCode","isScalarCode","Scalar","isQuaternionCode","isVectorCode","Vector","isMatrixCode","newScalarCode","code","newQuaternionCode","newVectorCode","newMatrixCode","numberCode","quaternionCode","vectorCode","matrixCode","refScalarCode","createNumberRefCode","refQuaternionCode","createQuaternionRefCode","refVectorCode","refMatrixCode","ConstantCode","E","ex","ey","ez","ReservedReferences","DefaultScalarCode","DefaultQuaternionCode","vector0Code","apply","BaseCodeGenContext","symbols","typeCode","arg","createCodeGenContext","FunctionOpMap","createUnaryScalarCodeGen","tan","asin","acos","atan","sinh","cosh","tanh","exp","log","T","withTypeCode","qrot","addErrors","errorByCode","norma","cyl","cyl1","sphere1","inv","v","Inverse","createQuaternionInvCode","inverse","createMatrixInvCode","FunctionKeywords","UnaryOpMap","merge","createNegQuaternionCode","assertRuleNode","expressionCodeGen","exprCodeGen","reduce","sum1Ctx","sum2Ctx","sumCodeGen","opsNode","createConcatSS","insertAt","createInsertCode","createAppendScalarCode","ac","bc","concatCodeGen","exprSuffixCodeGen","factor1Ctx","factor2Ctx","factorCodeGen","createAddSSCode","createAddQQCode","addCodeGen","createSubSSCode","createSubSQCode","createSubQSCode","createSubQQCode","subCodeGen","sumSuffix","unary1Ctx","unary2Ctx","unaryCodeGen","createMulSSCode","createMulQQCode","createScalarMulCode","mulCodeGen","createDivSSCode","createDivSQCode","createDivQSCode","createDivQQCode","createDivMMCode","divCodeGen","factorSuffixCodeGen","reduceRight","locCtx","op","unaryOpCodeGen","baseCode","baseCtx","expCtx","terminalCodeGen","expCode","pow","powSuffix","powCodeGen","createScalarFunctionCode","vn","kn","idCodeGen","braketCodeGen","modCtx","createModQuaternionCode","createModVectorCode","moduleCodeGen","VersionPattern","SystemDefinitionSchema","properties","version","pattern","items","required","additionalProperties","keywords","mapBodies","mapper","mapBody","mapBodiesPR","mapperP","mapperR","mapBodyPR","mapSystem","mapValues","extractDependencies","tree","filter","dep","concatErrors","u","fromPairs","t1","u1","zipSystemStructure","closure","allValues","names","uniq","ii","to","concatValues","args","orderedDependencies","deps","deepFirstTraverse","acc","deps1","acc1","dagKeys","codeGen","astsMap","resolver","symbolDeps","symbolKeys","clos","loopKeys","difference","orderedKeys","loopSymbolTable","seedTable","loopErrors","allRef","missingRef","seedErrors","d","res","table","ttable","terrors","nodeCodeGen","depErrors","DefaultPosition","DefaultRotation","transitionCodeGen","statusTable","astMaps","asts","varsTable","defaults","ctxMap","sysErrors","validateSystemDefinition","json","Validator","validate","throwError","cpatt","vpatt","compile","parsed","parseSystemDefs","statusCodeGen","statusErrors","bodiesCodeCtx","posCodeCtx","posTypeCode","rotCodeCtx","bodiesCodeGen","bodiesTable","bodiesErrors","transitionTable","transitionErrors","statusCode","bodiesCode","transitionCode","KEY","DefaultDefinition","App","leibniz","alertShow","importModalShown","leib","localStorage","setItem","JSON","stringify","init","getItem","processDefs","reset","load","optionTitle","optionMessage","optionConfirmBtn","optionConfirm","optionShow","alertTitle","alertMessage","url","ajax","getJSON","pipe","tap","onLoaded","onLoadError","subscribe","msg","xhr","statusText","showAlert","content","hideAlert","hideImportPanel","exportFile","dtnum1","exporting","fluid","showImportPanel","showExportPanel","Tabs","Tab","FormGroup","FormControl","setMaxDt","importFile","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.94140b99.chunk.js","sourcesContent":["import _ from \"lodash\";\nconst Lexer = require('lex');\n\n/***********************************************************/\n/* Lexer                                                   */\n/***********************************************************/\n\nconst IdentifierRegex = /[a-zA-Z_][a-zA-Z0-9_]*/;\nconst NumberRegex = /\\d+\\.?\\d*/;\nconst ExpNumberRegex = /\\d+\\.?\\d*[eE][+-]?\\d+/;\nconst SingleIdentifierRegex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\nconst BaseVectorRegex = /^e(\\d+)$/;\nconst KroneckerRegex = /^I(\\d+)$/;\n\nconst Keywords = [\n    'sin',\n    'cos',\n    'tan',\n    'asin',\n    'acos',\n    'atan',\n    'sinh',\n    'cosh',\n    'tanh',\n    'exp',\n    'log',\n    'sqrt',\n    'T',\n    'qrot',\n    'tr',\n    'n',\n    'cyl',\n    'sphere',\n    'cyl1',\n    'sphere1',\n    'inv',\n    'det',\n    'min',\n    'max',\n    'PI',\n    'e',\n    'i',\n    'j',\n    'k',\n    'dt',\n    'ex',\n    'ey',\n    'ez'\n];\n\nexport enum TokenType {\n    Number = 'number',\n    Id = 'identifier',\n    Symbol = 'symbol'\n}\n\nexport interface AbstractToken {\n    text: string;\n}\n\nexport interface NumberToken extends AbstractToken {\n    type: TokenType.Number;\n}\n\nexport interface IdToken extends AbstractToken {\n    type: TokenType.Id,\n}\n\nexport interface SymbolToken extends AbstractToken {\n    type: TokenType.Symbol,\n}\n\nexport type Token = NumberToken | IdToken | SymbolToken;\n\n/**\n * Returns the dimension of base vactor id or undefined if it is not\n * @param name \n */\nexport function baseVectorId(name: string): string | undefined {\n    const m = BaseVectorRegex.exec(name);\n    return m && m.length >= 2 ? m[1] : undefined;\n}\n\n/**\n * Returns the dimension of kroneker id or undefined if it is not\n * @param name \n */\nexport function kroneckerId(name: string): string | undefined {\n    const m = KroneckerRegex.exec(name);\n    return m && m.length >= 2 ? m[1] : undefined;\n}\n\n/**\n * \n * @param name \n */\nexport function identifierError(name: string): string | undefined {\n    if (!name.match(SingleIdentifierRegex)) {\n        return 'Name \"' + name + '\" must be an identifier';\n    } else if (Keywords.indexOf(name) >= 0) {\n        return 'Name \"' + name + '\" must not be a keyword';\n    } else if (baseVectorId(name) !== undefined) {\n        return 'Name \"' + name + '\" must not be a vector base keyword';\n    } else if (kroneckerId(name) !== undefined) {\n        return 'Name \"' + name + '\" must not be a kroneker keyword';\n    } else {\n        return undefined;\n    }\n}\n\nexport function toTokens(text: string): Token[] {\n    if (text === undefined) {\n        throw new Error('text undefined');\n    }\n    const lexer = new Lexer();\n    lexer.addRule(ExpNumberRegex, (lexeme: string): NumberToken => {\n        return {\n            type: TokenType.Number,\n            text: lexeme\n        };\n    })\n        .addRule(NumberRegex, (lexeme: string): NumberToken => {\n            return {\n                type: TokenType.Number,\n                text: lexeme\n            }\n        }).addRule(IdentifierRegex, (lexeme: string): IdToken => {\n            return {\n                type: TokenType.Id,\n                text: lexeme\n            }\n        })\n        .addRule(/\\s/, () => undefined)\n        .addRule(/./, (lexeme: string): SymbolToken => {\n            return {\n                type: TokenType.Symbol,\n                text: lexeme\n            }\n        });\n\n    const tokens: Token[] = [];\n    lexer.input = text;\n    for (; ;) {\n        const r: Token = lexer.lex();\n        if (r) {\n            tokens.push(r);\n        } else {\n            break;\n        }\n    }\n    return tokens;\n};\n\n\n/**\n * \n * @param tok \n */\nfunction isSymbol(tok: Token): tok is SymbolToken {\n    return tok.type === TokenType.Symbol;\n}\n\nfunction isNumber(tok: Token): tok is NumberToken {\n    return tok.type === TokenType.Number;\n}\n\nfunction isIdentifier(tok: Token): tok is IdToken {\n    return tok.type === TokenType.Id;\n}\n\n/***********************************************************/\n/* AST definitions                                         */\n/***********************************************************/\n\nexport interface TreeNode<T> {\n    node: T;\n    children: TreeNode<T>[];\n}\n\n/**\n * \n * @param tree \n * @param mapper \n */\nexport function mapTree<T, R>(tree: TreeNode<T>, mapper: (arg: T) => R): TreeNode<R> {\n    function map(tree: TreeNode<T>): TreeNode<R> {\n        const node = mapper(tree.node);\n        const children = tree.children.map(map);\n        return { node, children };\n    }\n    return map(tree);\n}\n\n/**\n * \n * @param tree \n * @param mapper \n */\nexport function deepFirstFlatMap<T, R>(tree: TreeNode<T>, mapper: (arg: T) => R): R[] {\n    function flatMap(tree: TreeNode<T>): R[] {\n        const node = mapper(tree.node);\n        const children = _.flatMap(tree.children, flatMap);\n        return _.concat(children, node);\n    }\n    return flatMap(tree);\n}\n\n/**\n * \n * @param tree \n * @param mapper \n */\nexport function deepLastFlatMap<T, R>(tree: TreeNode<T>, mapper: (arg: T) => R): R[] {\n    function flatMap(tree: TreeNode<T>): R[] {\n        const node = mapper(tree.node);\n        const children = _.flatMap(tree.children, flatMap);\n        return _.concat([node], children);\n    }\n    return flatMap(tree);\n}\n\n/**\n * \n * @param tree \n * @param predicate \n */\nexport function filterTree<T>(tree: TreeNode<T>, predicate: (arg: T) => boolean): TreeNode<T> | undefined {\n    function filter(tree: TreeNode<T>): TreeNode<T> | undefined {\n        if (predicate(tree.node)) {\n            const children = tree.children\n                .map(filter)\n                .filter(node => node !== undefined)\n                .map(node => node as TreeNode<T>)\n            return children.length > 0 ? { node: tree.node, children } : undefined\n        } else {\n            return undefined;\n        }\n    }\n    return filter(tree);\n}\n\nexport enum ASTNodeType {\n    Id = 'id',\n    Number = 'number',\n    Sym = 'sym',\n    End = 'end',\n    Rule = 'rule'\n};\n\ninterface IdNode {\n    type: ASTNodeType.Id;\n    id: string;\n}\n\ninterface NumberNode {\n    type: ASTNodeType.Number;\n    value: string;\n}\n\ninterface SymbolNode {\n    type: ASTNodeType.Sym;\n    symbol: string;\n}\n\ninterface EndNode {\n    type: ASTNodeType.End\n}\n\nexport interface RuleNode {\n    type: ASTNodeType.Rule;\n    rule: string;\n}\n\nexport type ASTNode = IdNode | NumberNode | SymbolNode | EndNode | RuleNode;\n\nexport const endAST: TreeNode<ASTNode> = {\n    node: {\n        type: ASTNodeType.End\n    },\n    children: []\n};\n\n/**\n * \n * @param id \n */\nexport function createIdAST(id: string): TreeNode<ASTNode> {\n    return {\n        node: { type: ASTNodeType.Id, id },\n        children: []\n    };\n}\n\n/**\n * \n * @param value \n */\nexport function createNumberAST(value: string): TreeNode<ASTNode> {\n    return {\n        node: { type: ASTNodeType.Number, value },\n        children: []\n    };\n}\n\n/**\n * \n * @param symbol \n */\nexport function createSymbolAST(symbol: string): TreeNode<ASTNode> {\n    return {\n        node: { type: ASTNodeType.Sym, symbol },\n        children: []\n    };\n}\n\n/**\n * \n * @param rule \n * @param node \n */\nexport function createOptionalAST(rule: string, node?: TreeNode<ASTNode>): TreeNode<ASTNode> {\n    return {\n        node: { type: ASTNodeType.Rule, rule },\n        children: node ? [node] : []\n    };\n}\n\n/**\n * \n * @param rule \n * @param seq \n */\nexport function createSeqAST(rule: string, children: TreeNode<ASTNode>[]): TreeNode<ASTNode> {\n    return {\n        node: { type: ASTNodeType.Rule, rule },\n        children\n    };\n}\n\n/**\n * \n * @param rule \n * @param nodes \n */\nexport function createRepeatAST(rule: string, children: TreeNode<ASTNode>[]): TreeNode<ASTNode> {\n    return {\n        node: { type: ASTNodeType.Rule, rule },\n        children\n    };\n}\n\n/**\n * \n */\nexport const DefaultASTNode = createSeqAST('expression', [\n    createSeqAST('expr', [\n        createSeqAST('sum', [\n            createSeqAST('factor', [\n                createSeqAST('unary', [\n                    createRepeatAST('unary-op*', []),\n                    createSeqAST('pow', [\n                        createNumberAST('0'),\n                        createRepeatAST('pow-suffix*', [\n                        ])\n                    ])\n                ]),\n                createRepeatAST('factor-suffix*', [])\n            ]),\n            createRepeatAST('sum-suffix*', [])\n        ]),\n        createRepeatAST('expr-suffix*', [])\n    ]),\n    endAST\n]);\n\n\n/***********************************************************/\n/* Syntax definitions                                      */\n/***********************************************************/\n\nexport class SyntaxParserContext {\n    private _tokens: Token[];\n    private _current: number;\n    private _errors: string[];\n    private _node: TreeNode<ASTNode> | undefined;\n    private _rules: Record<string, SyntaxRule>;\n\n    constructor(rules: Record<string, SyntaxRule>, tokens: Token[], current: number = 0, node?: TreeNode<ASTNode>, errors: string[] = []) {\n        this._rules = rules;\n        this._tokens = tokens;\n        this._current = current;\n        this._errors = errors;\n        this._node = node;\n    }\n\n    get tokens() { return this._tokens; }\n    get current() { return this._current; }\n    get errors() { return this._errors; }\n    get node() { return this._node; }\n    get rules() { return this._rules; }\n\n    /**\n     * \n     * @param id \n     */\n    rule(id: string): SyntaxRule | undefined { return this.rules[id]; }\n\n    /**\n     * \n     */\n    token(): Token | undefined {\n        const { tokens, current } = this;\n        return current < tokens.length ? tokens[current] : undefined;\n    }\n\n    /**\n     * \n     */\n    next(): SyntaxParserContext {\n        const { tokens, current } = this;\n        return current < tokens.length ?\n            new SyntaxParserContext(this.rules, tokens, current + 1, this.node, this.errors) :\n            this;\n    }\n\n    /**\n     * \n     * @param node \n     */\n    withNode(node: TreeNode<ASTNode> | undefined): SyntaxParserContext {\n        return new SyntaxParserContext(this.rules, this.tokens, this.current, node, this.errors);\n    }\n\n    /**\n     * \n     * @param errors \n     */\n    withErrors(errors: string[]): SyntaxParserContext {\n        return new SyntaxParserContext(this.rules, this.tokens, this.current, this.node, errors);\n    }\n\n    /**\n     * \n     * @param error \n     */\n    addError(error: string): SyntaxParserContext {\n        const pos = this.token()?.text || '<EOT>';\n        return this.withErrors(_.concat(this.errors, `${error}, found ${pos}`));\n    }\n}\n\n/**\n * \n * @param syntax \n * @param text \n */\nexport function buildSyntaxParserContext(text: string, syntax: Record<string, SyntaxRule> = systemSyntax) {\n    const tokens = toTokens(text);\n    return new SyntaxParserContext(syntax, tokens);\n}\n\ntype SyntaxRule = (ctx: SyntaxParserContext) => SyntaxParserContext;\n\n/**\n *\n * @param ctx\n */\nexport const IdExpr: SyntaxRule = ctx => {\n    const tok = ctx.token();\n    if (!tok) {\n        return ctx.addError('<id> expected');\n    }\n    if (!isIdentifier(tok)) {\n        return ctx.addError('<id> expected');\n    }\n    const node = createIdAST(tok.text);\n    return ctx.next().withNode(node);\n};\n\n/**\n * \n * @param keyword \n */\nexport function keywordExpr(keyword: string): SyntaxRule {\n    return ctx => {\n        const tok = ctx.token();\n        if (!tok || !isIdentifier(tok) || tok.text !== keyword) {\n            return ctx.addError(`${keyword} expected`);\n        }\n        const node = createIdAST(tok.text);\n        return ctx.next().withNode(node);\n    };\n}\n\n/**\n * \n * @param ctx \n */\nexport const NumberExpr: SyntaxRule = ctx => {\n    const tok = ctx.token();\n    if (!tok) {\n        return ctx.addError('<number> expected');\n    }\n    if (!isNumber(tok)) {\n        return ctx.addError('<number> expected');\n    }\n    const node = createNumberAST(tok.text);\n    return ctx.next().withNode(node);\n};\n\n/**\n * \n * @param ctx \n */\nexport const endExpr: SyntaxRule = ctx => {\n    const tok = ctx.token();\n    return tok ?\n        ctx.addError('<EOF> expected') :\n        ctx.withNode(endAST);\n};\n\n/**\n * \n * @param symbol \n */\nexport function symbolExpr(symbol: string): SyntaxRule {\n    return ctx => {\n        const tok = ctx.token();\n        if (!tok || !isSymbol(tok) || tok.text !== symbol) {\n            return ctx.addError(`${symbol} expected`);\n        }\n        const node = createSymbolAST(symbol);\n        return ctx.next().withNode(node);\n    };\n}\n\n/**\n * \n * @param rule \n */\nexport function nonTermExpr(rule: string): SyntaxRule {\n    return ctx => {\n        const r = ctx.rule(rule);\n        return !!r ?\n            r(ctx) :\n            ctx.addError(`Rule <${rule}> not found`);\n    }\n}\n\n/**\n * \n * @param id \n * @param seq \n */\nexport function seqExpr(id: string, ...seq: SyntaxRule[]): SyntaxRule {\n    return ctx => {\n        var nodes: TreeNode<ASTNode>[] = [];\n        var ctx1 = ctx;\n        for (var i = 0; i < seq.length; i++) {\n            const ctx2 = seq[i](ctx1);\n            if (ctx2.errors.length > ctx1.errors.length) {\n                // Invalid expression\n                return ctx2.addError(`<${id}> expected`);\n            }\n            if (ctx2.node) {\n                nodes.push(ctx2.node);\n            }\n            ctx1 = ctx2;\n        }\n        const node = createSeqAST(id, nodes);\n        return ctx1.withNode(node);\n    };\n}\n\n/**\n * \n * @param id \n * @param alts \n */\nexport function altExpr(id: string, ...alts: SyntaxRule[]): SyntaxRule {\n    return ctx => {\n        for (var i = 0; i < alts.length; i++) {\n            const ctx1 = alts[i](ctx);\n            if (ctx1.errors.length === ctx.errors.length) {\n                return ctx1;\n            }\n        }\n        // Invalid expression\n        return ctx.addError(`<${id}> expected`);\n    };\n}\n\n/**\n * \n * @param id \n * @param opt \n */\nexport function optExpr(id: string, opt: SyntaxRule): SyntaxRule {\n    return ctx => {\n        const ctx1 = opt(ctx);\n        if (ctx1.errors.length > ctx.errors.length) {\n            // Invalid expression\n            return ctx.withNode(createOptionalAST(id));\n        }\n        const node = createOptionalAST(id, ctx1.node);\n        return ctx1.withNode(node);\n    };\n}\n\n/**\n * \n * @param id \n * @param rule \n */\nexport function repeatExpr(id: string, rule: SyntaxRule): SyntaxRule {\n    return ctx => {\n        const nodes: TreeNode<ASTNode>[] = [];\n        var ctx1 = ctx;\n        for (; ;) {\n            const ctx2 = rule(ctx1);\n            if (ctx2.errors.length !== ctx1.errors.length) {\n                break;\n            }\n            if (ctx2.node) {\n                nodes.push(ctx2.node);\n            }\n            ctx1 = ctx2;\n        }\n        const node = createRepeatAST(id, nodes);\n        return ctx1.withNode(node);\n    };\n}\n\n/**\n * \n */\nexport const systemSyntax: Record<string, SyntaxRule> = {\n    'expression': seqExpr('expression',\n        nonTermExpr('expr'),\n        endExpr\n    ),\n    'expr': seqExpr('expr',\n        nonTermExpr('sum'),\n        nonTermExpr('expr-suffix*')\n    ),\n    'expr-suffix*': repeatExpr('expr-suffix*',\n        seqExpr('expr-suffix',\n            altExpr('expr-op',\n                symbolExpr(',')\n            ),\n            nonTermExpr('sum')\n        )\n    ),\n    'sum': seqExpr('sum',\n        nonTermExpr('factor'),\n        nonTermExpr('sum-suffix*')\n    ),\n    'sum-suffix*': repeatExpr('sum-suffix*',\n        seqExpr('sum-suffix',\n            altExpr('sum-op',\n                symbolExpr('+'),\n                symbolExpr('-')\n            ),\n            nonTermExpr('factor')\n        )\n    ),\n    'factor': seqExpr('factor',\n        nonTermExpr('unary'),\n        nonTermExpr('factor-suffix*')\n    ),\n    'factor-suffix*': repeatExpr('factor-suffix*',\n        seqExpr('factor-suffix',\n            altExpr('factor-op',\n                symbolExpr('*'),\n                symbolExpr('/')\n            ),\n            nonTermExpr('unary')\n        )\n    ),\n    'unary': seqExpr('unary',\n        repeatExpr('unary-op*',\n            altExpr('unary-op',\n                symbolExpr('+'),\n                symbolExpr('-'),\n                keywordExpr('sin'),\n                keywordExpr('cos'),\n                keywordExpr('tan'),\n                keywordExpr('asin'),\n                keywordExpr('acos'),\n                keywordExpr('atan'),\n                keywordExpr('sinh'),\n                keywordExpr('cosh'),\n                keywordExpr('tanh'),\n                keywordExpr('exp'),\n                keywordExpr('log'),\n                keywordExpr('sqrt'),\n                keywordExpr('T'),\n                keywordExpr('qrot'),\n                keywordExpr('tr'),\n                keywordExpr('n'),\n                keywordExpr('cyl'),\n                keywordExpr('sphere'),\n                keywordExpr('cyl1'),\n                keywordExpr('sphere1'),\n                keywordExpr('inv'),\n                keywordExpr('det'),\n                keywordExpr('min'),\n                keywordExpr('max')\n            )\n        ),\n        nonTermExpr('pow')\n    ),\n    'pow': seqExpr('pow',\n        nonTermExpr('terminal'),\n        nonTermExpr('pow-suffix*'),\n    ),\n    'pow-suffix*': repeatExpr('pow-suffix*',\n        seqExpr('pow-suffix',\n            symbolExpr('^'),\n            nonTermExpr('terminal'))\n    ),\n    'terminal': altExpr('terminal',\n        NumberExpr,\n        IdExpr,\n        nonTermExpr('bracket'),\n        nonTermExpr('module')\n    ),\n    'bracket': seqExpr('bracket',\n        symbolExpr('('),\n        nonTermExpr('expr'),\n        symbolExpr(')')\n    ),\n    'module': seqExpr('module',\n        symbolExpr('|'),\n        nonTermExpr('expr'),\n        symbolExpr('|')\n    )\n}\n\nexport interface ParsingResult {\n    ast: TreeNode<ASTNode>;\n    errors: string[];\n}\n\n/**\n * \n * @param text \n */\nexport function parse(text: string): ParsingResult {\n    const ctx = systemSyntax.expression(buildSyntaxParserContext(text));\n    const ast = ctx.errors.length > 0 || ctx.node === undefined ? DefaultASTNode : ctx.node;\n    return {\n        ast,\n        errors: ctx.errors\n    };\n}","import { Component } from 'react';\nimport { Engine, Scene } from 'babylonjs';\n\n/**\n * \n */\nexport interface SceneMountEvent {\n  engine: Engine;\n  scene: Scene;\n  canvas: HTMLCanvasElement;\n}\n\n/**\n * \n */\ninterface BabylonSceneProps {\n  canvasClass?: string;\n  onSceneMount?: (ev: any) => void;\n};\n\n/**\n * \n */\nexport class BabylonScene extends Component<BabylonSceneProps, {\n  canvas?: HTMLCanvasElement;\n  engine?: Engine;\n  scene?: Scene;\n}> {\n\n  /**\n   * \n   * @param props \n   */\n  constructor(props: BabylonSceneProps) {\n    super(props);\n    this.state = {};\n  }\n\n  /**\n   * \n   */\n  componentDidMount() {\n    window.addEventListener('resize', this.onResizeWindow);\n  }\n\n  /**\n   * \n   */\n  componentWillUnmount() {\n    window.removeEventListener('resize', this.onResizeWindow);\n  }\n\n  /**\n   * \n   */\n  private onResizeWindow = () => {\n    const { engine } = this.state;\n    engine?.resize();\n  }\n\n  /**\n   * \n   * @param canvas \n   */\n  private onCanvasLoaded(canvas: HTMLCanvasElement | null) {\n    const { onSceneMount } = this.props;\n    const { engine } = this.state;\n    if (canvas && !engine) {\n      const engine = new Engine(canvas, true,\n        {\n          deterministicLockstep: true,\n          lockstepMaxSteps: 4\n        });\n\n      const scene = new Scene(engine);\n\n      if (onSceneMount) {\n        onSceneMount({ scene, engine, canvas });\n      }\n\n      // Resize the babylon engine when the window is resized\n      this.setState({ engine, scene, canvas });\n    }\n  }\n\n  /**\n   * \n   */\n  render() {\n    return (\n      <canvas className={this.props.canvasClass} ref={c => this.onCanvasLoaded(c)} />\n    );\n  }\n}\n","import React, { FunctionComponent } from 'react';\nimport { InputGroup, Button, Form } from 'react-bootstrap';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faTrash } from '@fortawesome/free-solid-svg-icons'\n\nexport const ExprField: FunctionComponent<{\n  name: string;\n  expr?: string;\n  errors?: string[];\n  withoutDelete?: boolean;\n  onChange?: (arg: string) => void;\n  onDelete?: () => void;\n}> = ({ name, expr, errors = [], withoutDelete = false, onDelete, onChange }) => {\n  const hasErrors = errors.length > 0;\n  const errorItems = errors.map((text, idx) => (<li key={idx}>{text}</li>));\n\n  const deleteBtn = !withoutDelete ?\n    (<InputGroup.Append>\n      <Button variant=\"danger\"\n        onClick={() => { if (onDelete) { onDelete() } }}>\n        <FontAwesomeIcon icon={faTrash} />\n      </Button>\n    </InputGroup.Append>)\n    : '';\n\n  return (\n    <Form.Group >\n      <InputGroup size=\"sm\" >\n        <InputGroup.Prepend>{name}</InputGroup.Prepend>\n        <Form.Control type=\"text\"\n          value={expr}\n          // onInput={(ev) => { if (onChange) { onChange(ev.target.value); } }}\n          onChange={(ev) => { if (onChange) { onChange(ev.target.value); } }}\n          isValid={!hasErrors}\n          isInvalid={!!hasErrors} />\n        {deleteBtn}\n        <Form.Control.Feedback type=\"invalid\">\n          <ul>{errorItems}</ul>\n        </Form.Control.Feedback>\n      </InputGroup>\n    </Form.Group >\n  );\n}\n","import React, { FunctionComponent } from 'react';\nimport { Modal, Button } from 'react-bootstrap';\n\n/**\n * \n * @param param0 \n */\nexport const OptionPanel: FunctionComponent<{\n  show: boolean;\n  title?: string;\n  message?: string;\n  confirmButton: string;\n  onCancel?: () => void;\n  onConfirm?: () => void;\n}> = ({ show, title, message, confirmButton, onCancel, onConfirm }) => {\n\n  return (\n    <Modal show={show}\n      size=\"sm\"\n      onHide={() => { if (onCancel) { onCancel(); } }}>\n      <Modal.Header closeButton>\n        <Modal.Title>{title}</Modal.Title>\n      </Modal.Header>\n      <Modal.Body>{message}</Modal.Body>\n      <Modal.Footer>\n        <Button variant=\"primary\" onClick={() => { if (onCancel) { onCancel(); } }}>Cancel</Button>\n        <Button variant=\"danger\" onClick={() => { if (onConfirm) { onConfirm(); } }}>{confirmButton}</Button>\n      </Modal.Footer>\n    </Modal>\n  );\n}\n","import React, { Component } from 'react';\nimport { InputGroup, Button, Card, Form, Accordion } from 'react-bootstrap';\nimport { ExprField } from './ExprField';\nimport _ from 'lodash';\nimport { OptionPanel } from './OptionPanel';\nimport { v5 as uuidv5 } from 'uuid';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faPlus } from '@fortawesome/free-solid-svg-icons'\nimport { identifierError } from '../modules/leibniz-parser';\nimport { Errors } from '../modules/leibniz-defs';\n\nconst ns = uuidv5('http://www.mmarini.org', uuidv5.URL);\n\ninterface DefsPanelProps {\n  panelKey: string;\n  title: string;\n  defs?: Record<string, string>;\n  errors?: Record<string, Errors>;\n  onChange?: (id: string, value: Record<string, string>) => void;\n};\n\n/**\n * \n */\nexport class DefsPanel extends Component<DefsPanelProps, {\n  deleteModalShown: boolean;\n  newName: string;\n  modalTitle?: string;\n  modalMessage?: string;\n  optionAction?: () => void;\n}>{\n\n  /**\n   * \n   * @param props \n   */\n  constructor(props: DefsPanelProps) {\n    super(props);\n    this.state = {\n      deleteModalShown: false,\n      newName: ''\n    };\n  }\n\n  /**\n   * \n   * @param id \n   * @param value \n   */\n  private onChange(id: string, value: string) {\n    const { onChange, panelKey, defs } = this.props;\n    if (onChange && defs) {\n      const newConf = _.clone(defs);\n      newConf[id] = value;\n      onChange(panelKey, newConf);\n    }\n  }\n\n  /**\n   * \n   * @param id \n   */\n  private onDelete(id: string) {\n    this.showOptionPanel(\n      'Remove \"' + id + '\" definition ?',\n      'The definition \"' + id + '\" will be removed from the list.',\n      () => this.deleteDefs(id));\n  }\n\n  /**\n   * \n   * @param title \n   * @param message \n   * @param action \n   */\n  private showOptionPanel(title: string, message: string, action: () => void) {\n    this.setState({\n      deleteModalShown: true,\n      modalTitle: title,\n      modalMessage: message,\n      optionAction: action\n    });\n  }\n\n  /**\n   * \n   * @param id \n   */\n  private deleteDefs(id: string) {\n    const { onChange, panelKey, defs } = this.props;\n    if (onChange && defs) {\n      const newConf = _.omit(defs, id);\n      onChange(panelKey, newConf);\n    }\n    this.hideOptionPanel();\n  }\n\n  /**\n   * \n   */\n  private hideOptionPanel() {\n    this.setState({\n      deleteModalShown: false\n    });\n  }\n\n  /**\n   * \n   */\n  private onAdd() {\n    const { onChange, panelKey,defs } = this.props;\n    if (onChange&&defs) {\n      const { newName } = this.state;\n      const newConf = _.clone(defs);\n      newConf[newName] = '0';\n      onChange(panelKey, newConf);\n      this.setState({ newName: '' });\n    }\n  }\n\n  /**\n   * \n   * @param name \n   */\n  onName(name: string) {\n    this.setState({ newName: name });\n  }\n\n  /**\n   * \n   * @param name \n   */\n  newNameError(name: string) {\n    const { defs } = this.props;\n    if (name === '') {\n      return 'Identifier is required';\n    }\n    const error = identifierError(name);\n    if (error) {\n      return error;\n    }\n    if (defs && defs[name] !== undefined) {\n      return 'Definition already exists';\n    }\n    return '';\n  }\n\n  render() {\n    const { title, defs, errors } = this.props;\n    const {\n      deleteModalShown, modalTitle, modalMessage, optionAction,\n      newName\n    } = this.state;\n    const newNameError = this.newNameError(newName);\n\n    const fieldList = _(defs)\n      .toPairs()\n      .sortBy(ary => ary[0])\n      .map(ary => {\n        const key = ary[0];\n        const value = ary[1];\n        const id = uuidv5(key, ns);\n        return { id, key, value };\n      }).value();\n\n    const hasNewNameError = newNameError !== ''\n    return (\n      <Accordion defaultActiveKey=\"0\">\n        <Card>\n          <Accordion.Toggle as={Card.Header} eventKey=\"0\">\n            {title}\n          </Accordion.Toggle>\n          <Accordion.Collapse eventKey=\"0\">\n            <Card.Body>\n              <Form.Group controlId=\"validationAdd\">\n                <InputGroup size=\"sm\" >\n                  <InputGroup.Prepend>Name</InputGroup.Prepend>\n                  <Form.Control type=\"text\"\n                    value={newName}\n                    onChange={(ev) => this.onName(ev.target.value)}\n                    isValid={!hasNewNameError}\n                    isInvalid={!!hasNewNameError} />\n                  <InputGroup.Append>\n                    <Button variant=\"primary\"\n                      onClick={() => this.onAdd()}\n                      disabled={hasNewNameError}>\n                      <FontAwesomeIcon icon={faPlus} />\n                      <span>Add definition</span>\n                    </Button>\n                  </InputGroup.Append>\n                  <Form.Control.Feedback type=\"invalid\">{newNameError}</Form.Control.Feedback>\n                </InputGroup>\n              </Form.Group>\n              <hr></hr>\n              {fieldList.map(({ id, key, value }) => (\n                <ExprField key={id} name={key}\n                  expr={value}\n                  errors={errors ? errors[key] : undefined}\n                  onChange={(value) => this.onChange(key, value)}\n                  onDelete={() => this.onDelete(key)}></ExprField>\n              ))}\n              <OptionPanel show={deleteModalShown}\n                title={modalTitle}\n                message={modalMessage}\n                confirmButton=\"Remove\"\n                onCancel={() => this.hideOptionPanel()}\n                onConfirm={() => { if (optionAction) { optionAction(); } }}\n              />\n            </Card.Body >\n          </Accordion.Collapse>\n        </Card>\n      </Accordion>\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport { Button } from 'react-bootstrap';\nimport { ExprField } from './ExprField';\nimport { OptionPanel } from './OptionPanel';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faPlus, faTrash } from '@fortawesome/free-solid-svg-icons'\nimport { BodyStructure, Errors } from '../modules/leibniz-defs';\n\ninterface BodyRowProps {\n  id: number;\n  body?: BodyStructure<string>;\n  errors?: BodyStructure<Errors>;\n  onChange?: (body: BodyStructure<string>) => void;\n  onDelete?: () => void;\n};\n\nexport class BodyRow extends Component<BodyRowProps, {\n  modalShown: boolean;\n}> {\n\n  constructor(props: BodyRowProps) {\n    super(props);\n    this.state = {\n      modalShown: false\n    };\n  }\n\n  /**\n   * \n   */\n  private onAddRotation() {\n    const { onChange, body } = this.props;\n    if (onChange && body) {\n      onChange({\n        position: body.position,\n        rotation: '1+0*i'\n      });\n    }\n  }\n\n  /**\n   * \n   */\n  showOptionPanel() {\n    this.setState({ modalShown: true });\n  }\n\n  /**\n   * \n   */\n  hideOptionPanel() {\n    this.setState({ modalShown: false });\n  }\n\n  /**\n   * \n   */\n  deleteRotation() {\n    const { onChange, body } = this.props;\n    if (onChange && body) {\n      onChange({ position: body.position });\n    }\n    this.hideOptionPanel();\n  }\n\n  /**\n   * \n   */\n  onDeleteRow() {\n    const { onDelete } = this.props;\n    if (onDelete) {\n      onDelete();\n    }\n  }\n\n  /**\n   * \n   * @param value \n   */\n  private onChangePosition(value: string) {\n    const { onChange, body } = this.props;\n    if (onChange && body) {\n      onChange({\n        position: value,\n        rotation: body.rotation\n      });\n    }\n  }\n\n  /**\n   * \n   * @param value \n   */\n  private onChangeRotation(value: string) {\n    const { onChange, body } = this.props;\n    if (onChange && body) {\n      onChange({\n        position: body.position,\n        rotation: value\n      });\n    }\n  }\n\n  render() {\n    const { body, errors } = this.props;\n    const rotField = body?.rotation ? (\n      <div>\n        <ExprField name=\"\"\n          expr={body.rotation} errors={errors?.rotation}\n          onChange={(value) => this.onChangeRotation(value)}\n          onDelete={() => this.showOptionPanel()}\n        />\n        <OptionPanel show={this.state.modalShown}\n          title=\"Remove rotation ?\"\n          message=\"The rotation will be removed from body\"\n          confirmButton=\"Remove\"\n          onConfirm={() => this.deleteRotation()}\n          onCancel={() => this.hideOptionPanel()}\n        />\n      </div>\n    ) : (\n        <Button size=\"sm\" variant=\"primary\" onClick={() => this.onAddRotation()}>\n          <FontAwesomeIcon icon={faPlus} />\n        </Button>);\n    return (\n      <tr>\n        <td>{this.props.id + 1}</td>\n        <td>\n          <ExprField name=\"\" expr={body?.position}\n            errors={errors?.position}\n            onChange={(value) => this.onChangePosition(value)}\n            withoutDelete={true}\n          />\n        </td>\n        <td>\n          {rotField}\n        </td>\n        <td>\n          <Button size=\"sm\" variant=\"danger\" onClick={() => this.onDeleteRow()}>\n            <FontAwesomeIcon icon={faTrash} />\n          </Button>\n        </td>\n      </tr>\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport { Accordion, Button, Card, Table } from 'react-bootstrap';\nimport { default as _ } from 'lodash';\nimport { BodyRow } from './BodyRow';\nimport { OptionPanel } from './OptionPanel';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faPlus } from '@fortawesome/free-solid-svg-icons'\nimport { BodyStructure, Errors } from '../modules/leibniz-defs';\n\ninterface BodiesPanelProps {\n  bodies?: BodyStructure<string>[];\n  errors?: BodyStructure<Errors>[];\n  onChange?: (arg: BodyStructure<string>[]) => void;\n};\n\nexport class BodiesPanel extends Component<BodiesPanelProps, {\n  modalShown: boolean;\n  modalTitle?: string;\n  modalMessage?: string;\n  confirmAction?: () => void;\n}> {\n\n  constructor(props: BodiesPanelProps) {\n    super(props);\n    this.state = {\n      modalShown: false\n    };\n  }\n\n  /**\n   * \n   * @param title \n   * @param message \n   * @param action \n   */\n  private showOptionPanel(title: string, message: string, action: () => void) {\n    this.setState({\n      modalShown: true,\n      modalTitle: title,\n      modalMessage: message,\n      confirmAction: action\n    });\n  }\n\n  /**\n   * \n   */\n  private hideOptionPanel() {\n    this.setState({\n      modalShown: false\n    });\n  }\n\n  /**\n   * \n   */\n  private onAdd() {\n    const { onChange } = this.props;\n    if (onChange) {\n      const bodies = this.createBodies()\n      bodies.push({\n        position: '(0,0,0)'\n      });\n      onChange(bodies);\n    }\n  }\n\n  /**\n   * \n   * @param idx \n   */\n  private onDelete(idx: number) {\n    this.showOptionPanel(\n      'Remove body #' + (idx + 1),\n      'Body #' + (idx + 1) + ' will be removed from the list.',\n      () => this.deleteBody(idx)\n    );\n  }\n\n  /**\n   * \n   * @param idx \n   */\n  private deleteBody(idx: number) {\n    const { onChange } = this.props;\n    if (onChange) {\n      const bodies = this.createBodies();\n      bodies.splice(idx, 1);\n      onChange(bodies);\n    }\n    this.hideOptionPanel();\n  }\n\n  /**\n   * \n   */\n  private createBodies(): BodyStructure<string>[] {\n    return _.map(this.props.bodies, b => {\n      return {\n        position: b.position,\n        rotation: b.rotation\n      };\n    });\n  }\n\n  /**\n   * \n   * @param idx \n   * @param body \n   */\n  private onChange(idx: number, body: BodyStructure<string>) {\n    const { onChange } = this.props;\n    if (onChange) {\n      const bodies = this.createBodies();\n      bodies[idx] = body;\n      onChange(bodies);\n    }\n  }\n\n  /**\n   * \n   */\n  render() {\n    const { bodies, errors } = this.props;\n    const { modalShown, modalTitle, modalMessage, confirmAction } = this.state;\n    const rows = bodies ? _.map(bodies, (body, idx) =>\n      <BodyRow key={idx} id={idx} body={body}\n        errors={errors ? errors[idx] : undefined}\n        onChange={(body) => this.onChange(idx, body)}\n        onDelete={() => this.onDelete(idx)} />\n    ) : [];\n    return (\n      <Accordion defaultActiveKey=\"0\" >\n        <Card>\n          <Accordion.Toggle as={Card.Header} eventKey=\"0\">\n            Bodies\n          </Accordion.Toggle>\n          <Accordion.Collapse eventKey=\"0\">\n            <Card.Body>\n              <Button size=\"sm\" variant=\"primary\"\n                onClick={() => this.onAdd()}>\n                <FontAwesomeIcon icon={faPlus} />\n              Add new body\n            </Button>\n              <hr></hr>\n              <Table striped size=\"sm\">\n                <thead>\n                  <tr>\n                    <th scope=\"col\">#</th>\n                    <th scope=\"col\">Position</th>\n                    <th scope=\"col\">Rotation</th>\n                    <th scope=\"col\">Remove</th>\n                  </tr>\n                  {rows}\n                </thead>\n              </Table>\n              <OptionPanel show={modalShown}\n                title={modalTitle}\n                message={modalMessage}\n                confirmButton=\"Remove\"\n                onConfirm={() => { if (confirmAction) { confirmAction(); } }}\n                onCancel={() => this.hideOptionPanel()}\n              />\n            </Card.Body>\n          </Accordion.Collapse>\n        </Card>\n      </Accordion >\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport { DefsPanel } from './DefsPanel';\nimport { default as _ } from 'lodash';\nimport { BodiesPanel } from './BodiesPane';\nimport { Form } from 'react-bootstrap';\nimport { BodyStructure, SystemDefinition, SystemErrors } from '../modules/leibniz-defs';\n\ninterface EditorProps {\n  defs?: SystemDefinition;\n  errors?: SystemErrors;\n  onChange?: (conf: SystemDefinition) => void;\n};\n\n/**\n * \n */\nexport class Editor extends Component<EditorProps, {}> {\n  /**\n   * \n   * @param panelKey \n   * @param value \n   */\n  private onChange(panelKey: string, value: Record<string, string>) {\n    const { onChange, defs } = this.props;\n    if (onChange && defs) {\n      const newDefs = _.clone(defs);\n      (newDefs as any)[panelKey] = value;\n      onChange(newDefs);\n    }\n  }\n\n  /**\n   * \n   * @param bodies \n   */\n  private onBodiesChange(bodies: BodyStructure<string>[]) {\n    const { onChange, defs } = this.props;\n    if (onChange && defs) {\n      const newDefs = _.clone(defs);\n      newDefs.bodies = bodies;\n      onChange(newDefs);\n    }\n  }\n\n  render() {\n    const { defs, errors } = this.props;\n    return (\n      <Form noValidate >\n        <BodiesPanel bodies={defs?.bodies}\n          errors={errors?.bodies}\n          onChange={bodies => this.onBodiesChange(bodies)} />\n        <DefsPanel panelKey=\"funcs\" title=\"Functions\"\n          defs={defs?.funcs} errors={errors?.funcs}\n          onChange={(panelId, value) => this.onChange(panelId, value)}\n        />\n        <DefsPanel panelKey=\"initialStatus\" title=\"Initial Status\"\n          defs={defs?.initialStatus} errors={errors?.initialStatus}\n          onChange={(panelId, value) => this.onChange(panelId, value)}\n        />\n        <DefsPanel panelKey=\"transition\" title=\"Transition\"\n          defs={defs?.transition} errors={errors?.transition}\n          onChange={(panelId, value) => this.onChange(panelId, value)}\n        />\n      </Form>\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport { Modal, Button, Form } from 'react-bootstrap';\n\ninterface ImportFileProps {\n  show: boolean;\n  onCancel?: () => void\n  onFileRead?: (arg: string | ArrayBuffer | null) => void;\n  onError?: (arg: string) => void;\n};\n\n/**\n * \n */\nexport class ImportFile extends Component<ImportFileProps, {}>{\n\n  /**\n   * \n   * @param file \n   */\n  private onFileChange(file: Blob) {\n    const { onFileRead, onError } = this.props;\n    if (onFileRead) {\n      const fr = new FileReader();\n      fr.onload = (e) => {\n        onFileRead(fr.result);\n      };\n      fr.onerror = (event) => {\n        console.error(event);\n        if (onError) {\n          onError(event.toString());\n        }\n      };\n      try {\n        fr.readAsText(file);\n      } catch (e) {\n        console.error(e);\n        if (onError) {\n          onError(e.toString());\n        }\n      }\n    }\n  }\n\n  /**\n   * \n   */\n  render() {\n    const { show, onCancel } = this.props;\n    return (\n      <Modal size=\"lg\" show={show} onHide={() => { if (onCancel) { onCancel(); } }}>\n        <Modal.Header closeButton>\n          <Modal.Title>Import definitions from file ?</Modal.Title>\n        </Modal.Header>\n        <Modal.Body>\n          <p>The definitions will be imported from the selected file.</p>\n          <Form>\n            <Form.File\n              label=\"Import file\"\n              custom\n              onChange={(ev: any) => this.onFileChange(ev.target.files[0])}\n            />\n          </Form>\n        </Modal.Body>\n        <Modal.Footer>\n          <Button variant=\"primary\" onClick={() => { if (onCancel) { onCancel(); } }}>Cancel</Button>\n        </Modal.Footer>\n      </Modal >\n    );\n  }\n}\n","import { Quaternion, Vector3 } from 'babylonjs';\nimport _ from 'lodash';\n\n/**\n * \n * @param condition \n * @param message \n */\nexport function assert(condition: boolean, message?: () => string) {\n    if (!condition) {\n        throw new Error(message ? message() : 'Assert failed');\n    }\n}\n\n/**\n * \n */\nexport class Matrix {\n    private _values: number[][];\n\n    /**\n     * \n     * @param values \n     */\n    constructor(values: number[][]) {\n        this._values = values;\n    }\n\n    get isMatrix() { return true; }\n    get rows() { return this._values.length; }\n    get cols() { return this.rows > 0 ? this._values[0].length : 0; }\n\n    private get flatten() {\n        return _.flatMap(_.range(0, this.rows), i =>\n            _.range(0, this.cols).map(j => this.get(i, j))\n        );\n    }\n\n    get(i: number, j: number = 0) { return this._values[i][j]; }\n\n    /**\n     * \n     */\n    toString() {\n        const result = _.range(0, this.rows).map(i =>\n            _.range(0, this.cols).map(j =>\n                this.get(i, j)).join(',')\n        ).map(row => `[${row}]`).join(',');\n        return `[${result}]`;\n    }\n\n    /**\n     * \n     * @param f \n     */\n    map(f: (v: number, i: number, j: number) => number) {\n        const result = _.range(0, this.rows).map(i =>\n            _.range(0, this.cols).map(j =>\n                f(this.get(i, j), i, j)));\n        return new Matrix(result);\n    }\n\n    /**\n     * \n     */\n    trace() {\n        const n = Math.min(this.rows, this.cols);\n        var trace = 0;\n        for (var i = 0; i < n; i++) {\n            trace += this.get(i, i);\n        }\n        return trace;\n    }\n\n    /**\n     * Returns the negate matrix\n     */\n    negate() {\n        return this.map(a => -a);\n    }\n\n    /**\n     * \n     * @param other \n     * @param f \n     */\n    zipMap(other: Matrix, f: (a: number, b: number, i: number, j: number) => number) {\n        assert(this.rows === other.rows && this.cols === other.cols,\n            () => `Assert failed: (this.rows === other.rows && this.cols === other.cols), this=${this.rows}x${this.cols}, other=${other.rows}x${other.cols}`);\n\n        const result = _.range(0, this.rows).map(i =>\n            _.range(0, this.cols).map(j =>\n                f(this.get(i, j), other.get(i, j), i, j)));\n        return new Matrix(result);\n    }\n\n    /**\n     * Returns the matrix by adding the paramter\n     * @param other \n     */\n    add(other: Matrix) {\n        return this.zipMap(other, _.add);\n    }\n\n    /**\n     * Returns the matrix by subtracting the paramter\n     * @param other \n     */\n    subtract(other: Matrix) {\n        return this.zipMap(other, _.subtract);\n    }\n\n    /**\n     * Returns a scaled matrix\n     * @param scale \n     */\n    scale(scale: number) {\n        return this.map(a => {\n            return a * scale\n        });\n    }\n\n    /**\n     * Returns a scaled matrix\n     * @param scale \n     */\n    divide(scale: number) {\n        return this.map(a => a / scale);\n    }\n\n    /**\n     * Returns a resized Matrix the filler element is 0\n     * \n     * @param rows \n     * @param cols \n     */\n    resize(rows: number, cols: number) {\n        const n = this.rows;\n        const m = this.cols;\n        const partRows = _(this._values)\n            .take(Math.min(n, rows))\n            .map(row => {\n                const col = _.take(row, Math.min(m, cols));\n                for (var i = 0; i < cols - m; i++) {\n                    col.push(0);\n                }\n                return col;\n            }).value();\n        const appendRows = rows > n ?\n            _.map(_.range(rows - n), () =>\n                _.map(_.range(cols), () => 0))\n            : [];\n        const res = _.concat(partRows, appendRows);\n        return new Matrix(res);\n    }\n\n    /**\n     * \n     */\n    transpose() {\n        const n = this.rows;\n        const m = this.cols;\n        const v = _.range(0, m).map(i =>\n            _.range(0, n).map(j =>\n                this.get(j, i)))\n        return new Matrix(v);\n    }\n\n    /**\n     * \n     * @param other \n     */\n    multiply(other: Matrix) {\n        assert(this.cols === other.rows,\n            () => 'Assert failed: (this.cols === other.rows), this.cols=' + this.cols\n                + ',other.rows=' + other.rows);\n\n        const n = this.rows;\n        const m = other.cols;\n        const l = this.cols;\n        const v = _.range(0, n).map(i =>\n            _.range(0, m).map(j =>\n                _.sum(_.range(0, l).map(k =>\n                    this.get(i, k) * other.get(k, j)))));\n        return new Matrix(v);\n    }\n\n    /**\n     * \n     * @param other \n     */\n    dot(other: Matrix) {\n        assert(this.cols === 1,\n            () => `Assert failed: (this.cols === 1), this.cols=${this.cols}`);\n        assert(other.cols === 1,\n            () => `Assert failed: (other.cols === 1), other.cols=${other.cols}`);\n        assert(this.rows === other.rows,\n            () => `Assert failed: (this.rows === other.rows), this.rows=${this.rows}, other.rows=${other.rows}`);\n\n        const n = this.rows;\n        const v = _.sum(_.range(0, n).map(k =>\n            this.get(k, 0) * other.get(k, 0)));\n        return v;\n    }\n\n    /**\n     * \n     */\n    module() {\n        return Math.sqrt(this.dot(this));\n    }\n\n    /**\n     * \n     */\n    norma() {\n        const m = this.module();\n        return m > 1E-38 ? this.divide(m) : this;\n    }\n\n    /**\n     * \n     * @param other \n     */\n    append(other: Matrix) {\n        assert(this.rows === other.rows,\n            () => 'Assert failed: (this.rows === other.rows), this.rows=' + this.rows\n                + ',other.rows=' + other.rows);\n\n        const n = this.rows;\n        const m = this.cols;\n        const l = other.cols;\n        const v = _.range(0, n).map(i =>\n            _.range(0, m + l).map(j =>\n                j < m ? this.get(i, j) : other.get(i, j - m)));\n        return new Matrix(v);\n    }\n\n    /**\n     * \n     * @param idx \n     * @param value \n     */\n    insertAt(idx: number, value: number) {\n        assert(this.cols === 1,\n            () => 'Assert failed: (this.cols === 1), this.cols=' + this.cols);\n        assert(idx >= 0 && idx <= this.rows,\n            () => 'Assert failed: (idx >= 0 && idx <= this.rows), idx=' + idx + ', this.cols=' + this.cols);\n\n        const n = this.rows;\n        const v = _.range(0, n + 1).map(i =>\n            i < idx ?\n                [this.get(i)] :\n                i === idx ?\n                    [value] :\n                    [this.get(i - 1)]);\n        return new Matrix(v);\n    }\n\n    /**\n     * \n     */\n    qrot() {\n        assert(this.rows === 3 && this.cols === 1,\n            () => 'Assert failed: (this.rows === 3 && this.cols === 1), this.rows=' + this.rows\n                + ', this.cols=' + this.cols);\n        const x = this.get(0);\n        const y = this.get(1);\n        const z = this.get(2);\n        const len = this.module()\n        return Quaternion.RotationAxis(new Vector3(x, y, z), len);\n        // if (len > Number.MIN_VALUE) {\n        //     const hphi = len / 2.;\n        //     const w = Math.cos(hphi);\n        //     const sa = Math.sin(hphi);\n        //     const i = sa * x / len;\n        //     const j = sa * y / len;\n        //     const k = sa * z / len;\n        //     return new Quaternion(i, j, k, w);\n        // } else {\n        //     return new Quaternion(0, 0, 0, 1);\n        // }\n    }\n\n    /**\n     * \n     */\n    cyl() {\n        assert(this.rows === 3 && this.cols === 1,\n            () => 'Assert failed: (this.rows === 3 && this.cols === 1), this.rows=' + this.rows\n                + ', this.cols=' + this.cols);\n        const r = this.get(0);\n        const phi = this.get(1);\n        const z = this.get(2);\n        return new Matrix([\n            [r * Math.sin(phi)],\n            [r * Math.cos(phi)],\n            [z]\n        ]);\n    }\n\n    /**\n     * \n     */\n    sphere() {\n        assert(this.rows === 3 && this.cols === 1,\n            () => 'Assert failed: ((this.rows === 3 && this.cols === 1), this.rows=' + this.rows\n                + ',this.cols=' + this.cols);\n        const r = this.get(0);\n        const theta = this.get(1);\n        const phi = this.get(2);\n        const rr = r * Math.sin(theta);\n        return new Matrix([\n            [rr * Math.cos(phi)],\n            [rr * Math.sin(phi)],\n            [r * Math.cos(theta)]\n        ]);\n    }\n\n    /**\n     * \n     */\n    cyl1() {\n        assert(this.rows === 3 && this.cols === 1,\n            () => 'Assert failed: (this.rows === 3 && this.cols === 1), this.rows=' + this.rows\n                + ', this.cols=' + this.cols);\n        const r = this.get(0);\n        const phi = this.get(1);\n        const sin = Math.sin(phi);\n        const cos = Math.cos(phi);\n        return new Matrix([\n            [cos, -r * sin, 0],\n            [sin, r * cos, 0],\n            [0, 0, 1]\n        ]);\n    }\n\n    /**\n     * \n     */\n    sphere1() {\n        assert(this.rows === 3 && this.cols === 1,\n            () => 'Assert failed: (this.rows === 3 && this.cols === 1), this.rows=' + this.rows\n                + ', this.cols=' + this.cols);\n\n        const r = this.get(0, 0);\n        const theta = this.get(1);\n        const phi = this.get(2);\n        const sint = Math.sin(theta);\n        const cost = Math.cos(theta);\n        const sinp = Math.sin(phi);\n        const cosp = Math.cos(phi);\n        const sincos = sint * cosp;\n        const sinsin = sint * sinp;\n        const coscos = cost * cosp;\n        return new Matrix([\n            [sincos, r * coscos, -r * sinsin],\n            [sinsin, r * cost * cosp, r * sincos],\n            [cost, -r * sint, 0]\n        ]);\n    }\n\n    /**\n     * \n     */\n    inverse() {\n        const { enchelon } = this.gaussJordan();\n        const n = this.rows;\n        const inv = _.map(enchelon, row => _.drop(row, n));\n        return new Matrix(inv);\n    }\n\n    /**\n     * \n     */\n    det() {\n        const { det } = this.gaussJordan();\n        return det;\n    }\n\n    /**\n     * \n     */\n    gaussJordan() {\n        assert(this.rows === this.cols,\n            () => 'Assert failed: (this.rows === this.cols), this.rows=' + this.rows\n                + ', this.cols=' + this.cols);\n        const n = this.rows;\n        const mtx = Array<number[]>(n);\n        for (var i = 0; i < n; i++) {\n            mtx[i] = Array(2 * n);\n        }\n        for (i = 0; i < n; i++) {\n            for (var j = 0; j < n; j++) {\n                mtx[i][j] = this.get(i, j);\n                mtx[i][j + n] = i === j ? 1 : 0;\n            }\n        }\n        var det = 1;\n        var h = 0; // pivot row\n        var k = 0; // pivot col\n        while (h < n && k < n) {\n            // Find pivot row\n            var imax = h;\n            var max = Math.abs(mtx[h][k]);\n            for (i = h + 1; i < n; i++) {\n                const mx = Math.abs(mtx[i][k]);\n                if (mx > max) {\n                    imax = i;\n                    max = mx;\n                }\n            }\n            if (max === 0) {\n                /* No pivot in this column, pass to next column */\n                k++;\n            } else {\n                //Swap row imax, h\n                const tr = mtx[imax];\n                mtx[imax] = mtx[h];\n                mtx[h] = tr;\n                det = -det;\n\n                for (i = h + 1; i < n; i++) {\n                    const f = mtx[i][k] / mtx[h][k];\n                    mtx[i][k] = 0;\n                    /* Do for all remaining elements in current row: */\n                    for (j = k + 1; j < 2 * n; j++) {\n                        mtx[i][j] -= mtx[h][j] * f;\n                    }\n                }\n                h++;\n                k++;\n            }\n        }\n        // Inverse matrix does not exist\n        assert(h === k, () => 'Inverse matrix does not exist');\n        // Reverse\n        for (h = n - 1; h >= 0; h--) {\n            for (i = 0; i < h; i++) {\n                // mtx[i][j] = mtx[i][j] + mtx[h][j] * f;\n                // mtx[i][h] + mtx[h][h] * f = 0\n                //f = -mtx[i][h]/mtx[h][h];\n                const f = mtx[i][h] / mtx[h][h];\n                mtx[i][h] = 0;\n                for (j = h + 1; j < 2 * n; j++) {\n                    // mtx[i][h] = 0 = mtx[i][h] - mtx[h][j] * f;\n                    mtx[i][j] -= mtx[h][j] * f;\n                }\n            }\n            for (j = h + 1; j < 2 * n; j++) {\n                mtx[h][j] /= mtx[h][h];\n            }\n            det *= mtx[h][h];\n            mtx[h][h] = 1;\n        }\n        return {\n            enchelon: mtx,\n            det: det\n        };\n    }\n\n    /**\n     * \n     */\n    min() { return _.min(this.flatten) ?? Number.NEGATIVE_INFINITY; }\n\n    /**\n     * \n     */\n    max() { return _.max(this.flatten) ?? Number.POSITIVE_INFINITY; }\n}\n\nexport type AnyValue = number | Quaternion | Matrix;\n\n/**\n * \n * @param value \n */\nexport function isNumber(value: AnyValue): value is number {\n    return typeof value === 'number';\n}\n\n/**\n * \n * @param value \n */\nexport function isQuaternion(value: AnyValue): value is Quaternion {\n    return (value as Quaternion).w !== undefined;\n}\n\n/**\n * \n * @param value \n */\nexport function isMatrix(value: AnyValue): value is Matrix {\n    return !!(value as Matrix).isMatrix;\n}\n\n/**\n * \n * @param values \n */\nexport function vector(...values: number[]): Matrix {\n    return new Matrix([values]).transpose();\n}\n\n/**\n * \n * @param values \n */\nexport function matrix(values: number[][]): Matrix {\n    return new Matrix(values);\n}","import _ from 'lodash';\nimport { InternalStatus, SystemRules } from \"./leibniz-defs\";\nimport { AnyValue, isMatrix, isNumber, isQuaternion } from \"./leibniz-tensor\";\n\n/**\n * \n * @param sys \n * @param dt \n * @param n \n */\nexport function generateData(sys: SystemRules, dt: number, n: number): InternalStatus[] {\n    var st = sys.initialStatus();\n\n    var states: InternalStatus[] = [st];\n    for (var i = 1; i < n; i++) {\n        st = sys.next(st, dt);\n        states.push(st);\n    }\n    return states;\n}\n\nfunction headers(n: AnyValue): string[] {\n    if (isNumber(n)) {\n        return [''];\n    }\n    if (isQuaternion(n)) {\n        return [' w', ' i', ' j', ' k'];\n    }\n    if (isMatrix(n)) {\n        if (n.cols === 1) {\n            return _.range(0, n.rows).map(i => ` ${i}`);\n        } else {\n            return _.flatMap(_.range(0, n.rows), i =>\n                _.range(0, n.cols).map(j => ` ${i},${j}`));\n        }\n    }\n    throw new Error(`unexpected value type ${n}`);\n}\n\nfunction row(n: AnyValue): string[] {\n    if (isNumber(n)) {\n        return [`${n}`];\n    }\n    if (isQuaternion(n)) {\n        return [`${n.w}`, `${n.x}`, `${n.y}`, `${n.z}`];\n    }\n    if (isMatrix(n)) {\n        if (n.cols === 1) {\n            return _.range(0, n.rows).map(i => `${n.get(i)}`);\n        } else {\n            return _.flatMap(_.range(0, n.rows), i =>\n                _.range(0, n.cols).map(j => `${n.get(i, j)}`));\n        }\n    }\n    throw new Error(`unexpected value type ${n}`);\n}\n\n/**\n * \n * @param data\n */\nexport function toCsv(data: InternalStatus[], sys: SystemRules): string {\n    const bodies = data.map(sys.bodies);\n    const ks = _.keys(data[0]).sort();\n    const hs = _.flatMap(ks, key => headers(data[0][key]).map(sfx => `\"${key}${sfx}\"`));\n    const hb = _.flatMap(_.range(0, bodies[0].length), i =>\n        [`x ${i}`, `y ${i}`, `z ${i}`, `w ${i}`, `i ${i}`, `j ${i}`, `k ${i}`]\n    );\n    const header = _.concat(hs, hb).join(',');\n    const dataRows = data.map((status, i) => {\n        const rs = _.flatMap(ks, k => row(status[k]));\n        const rb = _.flatMap(bodies[i], body => {\n            const p = row(body.position);\n            const r = body.rotation ? row(body.rotation) : ['', '', '', ''];\n            return _.concat(p, r);\n        })\n        return _.concat(rs, rb).join(',');\n    });\n    const result= _.concat(header, dataRows).join('\\r\\n') + '\\r\\n';\n    return result;\n}\n","import React, { Component } from 'react';\nimport { Button, Row, Form, Container } from 'react-bootstrap';\nimport { saveAs } from 'file-saver';\nimport { SystemRules } from '../modules/leibniz-defs';\nimport { generateData, toCsv } from '../modules/leibnitz-dumper';\n\ninterface DumpPanelProps {\n  rules?: SystemRules;\n};\n\n/**\n * \n */\nexport class DumpPanel extends Component<DumpPanelProps, {\n  counts: string;\n  dt: string;\n}> {\n\n  /**\n   * \n   * @param props \n   */\n  constructor(props: DumpPanelProps) {\n    super(props);\n    this.state = {\n      counts: '10',\n      dt: '0.1'\n    };\n  }\n\n  /**\n   * \n   */\n  private dumpData() {\n    const { rules } = this.props;\n    if (rules) {\n      const { dt: dtString, counts: countsString } = this.state;\n      const dt = parseFloat(dtString);\n      const counts = parseInt(countsString);\n      const data = generateData(rules, dt, counts);\n      const dumpData = toCsv(data, rules);\n      const blob = new Blob([dumpData], { type: \"text/plain;charset=utf-8\" });\n      saveAs(blob, \"dump.csv\");\n    }\n  }\n\n  /**\n   * \n   * @param value \n   */\n  private setCounts(value: string) {\n    this.setState({ counts: value });\n  }\n\n  /**\n   * \n   * @param value \n   */\n  private setDt(value: string) {\n    this.setState({ dt: value });\n  }\n\n  /**\n   * \n   */\n  render() {\n    const { rules } = this.props;\n    const dumpDisabled = rules === undefined;\n    return (\n      <Container>\n        <Row>\n          <Form noValidate inline>\n            <Form.Group controlId=\"formInlineName\">\n              <Form.Label>Counts</Form.Label>{' '}\n              <Form.Control type=\"text\" placeholder=\"Counts\"\n                onChange={ev => this.setCounts(ev.target.value)}\n                value={this.state.counts} />\n            </Form.Group>{' '}\n            <Form.Group controlId=\"formInlineName\" >\n              <Form.Label>dt</Form.Label>{' '}\n              <Form.Control type=\"text\" placeholder=\"dt\"\n                onChange={ev => this.setDt(ev.target.value)}\n                value={this.state.dt} />\n            </Form.Group>\n            <Button variant=\"primary\"\n              disabled={dumpDisabled}\n              onClick={() => this.dumpData()} >Download</Button>\n          </Form>\n        </Row>\n      </Container>\n    );\n  }\n}\n","import {\n    AnaglyphArcRotateCamera, ArcRotateCamera, Color3, DeviceOrientationCamera,\n    HemisphericLight, Mesh, MeshBuilder, Scene, StandardMaterial,\n    Vector3, VRDeviceOrientationArcRotateCamera, UniversalCamera\n} from 'babylonjs';\nimport { default as _ } from 'lodash';\nimport { SceneMountEvent } from '../react/SceneComponent';\nimport { SystemRules, BodyStatus, InternalStatus } from './leibniz-defs';\n\nexport enum CameraType {\n    DeviceOrientation = 'do',\n    Anaglyph = 'ac',\n    VRDeviceOrientation = 'vr',\n    ArcRotate = 'ar',\n    Universal = 'un'\n};\n\ninterface SceneOptions {\n    cameraType: CameraType;\n    cameraPosition: Vector3;\n    maxDt: number;\n    sunLightDirection: Vector3;\n};\n\nconst FPS = 60;\n\nconst Octahedron = 1;\n// const ElongatedSquareDipyramid = 12;\n\n/*\n * Returns the Color3 for HSB value (Hue, Saturation, Bright)\n */\nfunction fromHSB(h: number, s: number, b: number) {\n    var hc = null;\n    if (h <= 0) {\n        hc = Color3.Red();\n    } else if (h < 1 / 6) {\n        hc = new Color3(1, h * 6, 0);\n    } else if (h < 2 / 6) {\n        hc = new Color3(2 - 6 * h, 1, 0);\n    } else if (h < 3 / 6) {\n        hc = new Color3(0, 1, h * 6 - 2);\n    } else if (h < 4 / 6) {\n        hc = new Color3(0, 4 - h * 6, 1);\n    } else if (h < 5 / 6) {\n        hc = new Color3(h * 6 - 4, 0, 1);\n    } else if (h < 1) {\n        hc = new Color3(1, 0, 6 - h * 6);\n    } else {\n        hc = Color3.Red();\n    }\n    const sc = Color3.White().scale(1 - s).add(hc.scale(s));\n    return sc.scale(b);\n}\n\n/*\n * Returns the Color3 of heat color scale (Violet to Red)\n */\nfunction fromHeat(h: number) {\n    return fromHSB((1 - h) * 5 / 6, 1, 1 - (1 - h) * 0.2);\n}\n\n/**\n* \n* @param scene \n* @param options \n*/\nfunction createCamera(scene: Scene, options: SceneOptions) {\n    switch (options.cameraType) {\n        case CameraType.DeviceOrientation: {\n            const camera = new DeviceOrientationCamera('DevOr_camera', new Vector3(0, 0, 0), scene);\n            camera.position = options.cameraPosition;\n            camera.setTarget(Vector3.Zero());\n            camera.angularSensibility = 10;\n            // camera.moveSensibility = 10;\n            return camera;\n        }\n        case CameraType.Anaglyph: {\n            const camera = new AnaglyphArcRotateCamera('aar_cam', -Math.PI / 2, Math.PI / 4, 20, Vector3.Zero(), 0.033, scene);\n            camera.target = Vector3.Zero();\n            camera.setPosition(options.cameraPosition);\n            return camera;\n        }\n        case CameraType.VRDeviceOrientation: {\n            const camera = new VRDeviceOrientationArcRotateCamera('Camera', Math.PI / 2, Math.PI / 4, 25, new Vector3(0, 0, 0), scene);\n            camera.target = Vector3.Zero();\n            camera.setPosition(options.cameraPosition);\n            return camera;\n        }\n        case CameraType.ArcRotate: {\n            const camera = new ArcRotateCamera('ArcRotateCamera', 0, 0, 0, new Vector3(0, 0, 0), scene);\n            camera.wheelPrecision = 20;\n            camera.setPosition(options.cameraPosition);\n            return camera;\n        }\n        default: {\n            const camera = new UniversalCamera('UniversalCamera', options.cameraPosition, scene);\n            camera.inputs.addMouseWheel();\n            return camera;\n        }\n    }\n}\n\n/**\n * \n * @param scene \n * @param name \n * @param color \n */\nfunction createOcta(scene: Scene, name: string, color: Color3) {\n    const material = new StandardMaterial('Material_' + name, scene);\n    material.ambientColor = color;\n    material.diffuseColor = color;\n\n    const shape = MeshBuilder.CreatePolyhedron(\n        'Octa_' + name, {\n        type: Octahedron,\n        sizeX: 0.1,\n        sizeY: 0.2,\n        sizeZ: 0.05,\n    },\n        scene\n    );\n    shape.material = material;\n    return shape;\n}\n\n/**\n * \n * @param scene \n * @param name \n * @param color \n */\nfunction createSphere(scene: Scene, name: string, color: Color3) {\n    const material = new StandardMaterial('Material_' + name, scene);\n    material.ambientColor = color;\n    material.diffuseColor = color;\n\n    const sphere = MeshBuilder.CreateIcoSphere(\n        'Sphere_' + name, {\n        flat: false,\n        radius: 0.1,\n        subdivisions: 4,\n        updatable: false\n    },\n        scene);\n    sphere.material = material;\n    return sphere;\n}\n\n/**\n * Leibniz manages the 3D animation\n * \n * flow:\n * create\n * init (create and bind meshes to system, add time listener)\n * \n * setState to change to rules and recreate the new scene\n * \n * refresh to refresh the scene in case of resize\n */\nexport class Leibniz {\n    private _props: SceneMountEvent;\n    private _maxDt: number;\n    private _status?: InternalStatus;\n    private _rules?: SystemRules;\n    private _shapes: Mesh[];\n    private _remainderT: number;\n\n    /**\n     * \n     * @param props \n     */\n    constructor(props: SceneMountEvent) {\n        this._props = props;\n        this._maxDt = 1 / FPS;\n        this._shapes = [];\n        this._remainderT = 0;\n    }\n\n    /**\n     * \n     */\n    get props() { return this._props; }\n\n    /**\n     * \n     */\n    get rules() { return this._rules; }\n\n    /**\n     * \n     */\n    get status() { return this._status; }\n\n    /**\n     * \n     */\n    get shapes() { return this._shapes; }\n\n    /**\n     * \n     */\n    get maxDt() { return this._maxDt; }\n\n    /**\n     * \n     */\n    set maxDt(dt: number) { this._maxDt = dt; }\n\n    /**\n     * \n     * @param rules \n     */\n    private createShapes(bodies: BodyStatus[]) {\n        const { scene } = this.props;\n        const n = bodies.length;\n        const shapes = _.map(bodies, (body, i) => {\n            const name = 'Body' + i;\n            const color = fromHeat(n > 1 ? i / (n - 1) : 0);\n            const mesh = (body.rotation !== undefined)\n                ? createOcta(scene, name, color)\n                : createSphere(scene, name, color);\n            this.updateShape(mesh, body);\n            return mesh;\n        });\n        return shapes;\n    }\n\n    /**\n     * \n     */\n    set rules(rules: SystemRules | undefined) {\n        // Cleans up scene\n        _.each(this._shapes, shape =>\n            this.props.scene.removeMesh(shape, true)\n        );\n\n        if (rules) {\n            const status = rules.initialStatus();\n            const bodies = rules.bodies(status);\n            this._shapes = this.createShapes(bodies);\n            this._status = status;\n        } else {\n            this._status = undefined;\n            this._shapes = [];\n        }\n        this._rules = rules;\n    }\n\n    /**\n     * \n     * @param options \n     */\n    init(options?: Partial<SceneOptions>): Leibniz {\n        const { engine, scene } = this.props;\n\n        const _options = _.assign({\n            cameraType: CameraType.DeviceOrientation,\n            cameraPosition: new Vector3(0, 0, -10),\n            cameraMinZ: 0.5,\n            ambientColor: new Color3(0.2, 0.2, 0.2),\n            sunLightDirection: new Vector3(1, 1, -1),\n            sunLightIntensity: 0.7,\n            maxDt: 1 / FPS\n        }, options || {});\n\n        this._maxDt = _options.maxDt;\n\n        const camera = createCamera(this.props.scene, _options);\n        camera.attachControl(this.props.canvas, true);\n\n        // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\n        const light = new HemisphericLight(\n            'sunLight',\n            _options.sunLightDirection,\n            this.props.scene);\n        light.intensity = _options.sunLightIntensity;\n\n        scene.ambientColor = _options.ambientColor;\n        scene.onBeforeStepObservable.add((scene) => {\n            const { rules, status } = this;\n            if (rules && status) {\n                const ar = scene.getAnimationRatio() || 1;\n                const realDt = ar / FPS;\n                const dt = Math.min(this.maxDt, realDt);\n                var st = status;\n                for (var t = this._remainderT; t < realDt; t += dt) {\n                    st = rules.next(st, dt);\n                }\n                this._remainderT = t - realDt;\n                this._status = st;\n            }\n        });\n\n        // Adds callback handler on rendering loop\n        engine.runRenderLoop(() => {\n            this.refreshScene();\n            scene.render();\n        });\n        return this;\n    }\n\n    /**\n     *\n     */\n    private refreshScene() {\n        const { status, shapes, rules } = this;\n        if (status && rules) {\n            const bodies = rules.bodies(status);\n            _.zip(bodies, shapes).forEach(([body, shape]) => {\n                if (body && shape) {\n                    this.updateShape(shape, body);\n                }\n            });\n        }\n    }\n\n    /**\n     * \n     * @param shape \n     * @param body \n     */\n    private updateShape(shape: Mesh, body: BodyStatus) {\n        shape.position = new Vector3(\n            body.position.get(0),\n            body.position.get(1),\n            body.position.get(2));\n        if (body.rotation) {\n            shape.rotationQuaternion = body.rotation;\n        }\n    }\n\n    /**\n     * \n     */\n    refresh() {\n        this.props.engine.resize();\n    }\n\n    /**\n     * \n     */\n    resetStatus() {\n        const { rules } = this;\n        if (rules) {\n            this._status = rules.initialStatus();\n        }\n    }\n}\n","import React, { FunctionComponent } from 'react';\nimport { Navbar, Nav, NavDropdown } from 'react-bootstrap';\n\n/**\n * \n */\nexport const LbNavBar: FunctionComponent<Readonly<{\n  onReset?: () => void;\n  onLoad?: (arg: string) => void;\n  onImport?: () => void;\n  onExport?: () => void;\n}>> = ({ onReset, onLoad, onImport, onExport }) => {\n  const home = process.env.REACT_APP_BASENAME;\n  return (\n    <Navbar variant=\"dark\" bg=\"dark\" expand=\"lg\" >\n      <Navbar.Brand href=\"http://www.mmarini.org\">www.mmarini.org</Navbar.Brand>\n      <Navbar.Toggle aria-controls=\"navbar-nav\" />\n      <Navbar.Collapse id=\"navbar-nav\">\n        <Nav className=\"mr-auto\">\n          <Nav.Link href={home}>Leibniz {process.env.REACT_APP_VERSION}</Nav.Link>\n          <NavDropdown id=\"predefined-menu\" title=\"Predefined\">\n            <NavDropdown.Item\n              onSelect={() => { if (onReset) { onReset(); } }}>\n              Reset\n              </NavDropdown.Item>\n            <NavDropdown.Item\n              onSelect={() => { if (onLoad) { onLoad('sample1.json'); } }}>\n              Basic sample\n            </NavDropdown.Item>\n            <NavDropdown.Item\n              onSelect={() => { if (onLoad) { onLoad('bodies3.json'); } }}>\n              3 Bodies\n            </NavDropdown.Item>\n            <NavDropdown.Item\n              onSelect={() => { if (onLoad) { onLoad('solaris.json'); } }}>\n              Solaris (Earth - Sun)\n            </NavDropdown.Item>\n            <NavDropdown.Item\n              onSelect={() => { if (onLoad) { onLoad('selene.json'); } }}>\n              Selene (Moon -Earth)\n              </NavDropdown.Item>\n          </NavDropdown>\n          <Nav.Link\n            onClick={() => { if (onImport) { onImport(); } }}>\n            Import\n          </Nav.Link>\n          <Nav.Link\n            onClick={() => { if (onExport) { onExport(); } }}>\n            Export\n          </Nav.Link>\n          <Nav.Link href=\"https://github.com/m-marini/leibniz/wiki/Expression-syntax\" target=\"leibniz-help\">\n            Help\n          </Nav.Link>\n        </Nav>\n      </Navbar.Collapse>\n    </Navbar>\n  );\n}\n","import React, { FunctionComponent } from 'react';\nimport { Alert } from 'react-bootstrap';\n\nexport const LbAlert: FunctionComponent<Partial<{\n    isVisible: boolean;\n    onClose: () => void;\n    title: string;\n    message: string;\n}>> = ({ isVisible = false, onClose, title, message }) => {\n\n    return isVisible ? (\n        <Alert variant=\"danger\" dismissible\n            onClose={() => { if (onClose) { onClose(); } }}>\n            <Alert.Heading>{title}</Alert.Heading>\n            <p>{message}</p>\n        </Alert>\n    ) : (\n            <span />\n        );\n}\n","import { Quaternion } from \"babylonjs\";\nimport { AnyValue, Matrix } from \"./leibniz-tensor\";\n\nexport interface BodyStructurePR<P, R> {\n    position: P;\n    rotation?: R;\n}\n\nexport type BodyStructure<T> = BodyStructurePR<T, T>;\n\nexport interface SystemStructure<T> {\n    bodies: BodyStructure<T>[];\n    initialStatus: Record<string, T>;\n    transition: Record<string, T>;\n    funcs: Record<string, T>;\n}\n\nexport const CurrentSysDefVersion = \"0.1\";\n\nexport interface SystemDefinition extends SystemStructure<string> {\n    version: string;\n}\n\nexport type InternalStatus = Record<string, AnyValue>;\n\nexport type ValueFunction<T extends AnyValue> = (arg: InternalStatus) => T;\n\nexport type AnyValueFunction = ValueFunction<AnyValue>;\n\n/**\n * The body status with a position and an optional rotation\n */\nexport type BodyStatus = BodyStructurePR<Matrix, Quaternion>;\n\nexport interface SystemRules {\n    bodies: (ctx: InternalStatus) => BodyStatus[];\n    initialStatus: () => InternalStatus;\n    next: (ctx: InternalStatus, dt: number) => InternalStatus;\n}\n\nexport type Errors = string[];\n\nexport type SystemErrors = SystemStructure<Errors>;\n\nexport interface CompilerResult {\n    rules: SystemRules;\n    errors: SystemErrors;\n};\n","import { Quaternion } from 'babylonjs';\nimport _ from 'lodash';\nimport {\n    createConstantCode, createNegMatrixCode, createNegQuaternionCode, createNegScalarCode, createPowCode,\n    createScalarFunctionCode, createTransposeCode, createQRotCode, createTrCode, createNormalCode, createCylCode,\n    createCyl1Code, createSphereCode, createSphere1Code, createScalarInvCode, createQuaternionInvCode, createMatrixInvCode,\n    createDetCode, createMinCode, createMaxCode, createMulSSCode, createMulSQCode, createMulSMCode, createMulQQCode,\n    createMulMMCode, createNumberRefCode, createDivSSCode, createDivSQCode, createDivQSCode,\n    createDivQQCode,\n    createDivMSCode,\n    createDivMMCode,\n    createAddSSCode,\n    createAddSQCode,\n    createAddQQCode,\n    createAddMMCode,\n    createSubSSCode,\n    createSubSQCode,\n    createSubQSCode,\n    createSubQQCode,\n    createSubMMCode,\n    createModQuaternionCode,\n    createModVectorCode,\n    createConcatSS,\n    createInsertCode,\n    createAppendScalarCode,\n    createResizeCode,\n    createAppendCode,\n    createScalarMulCode,\n    createQuaternionRefCode,\n    createMatrixRefCode,\n    createModScalarCode\n} from \"./leibniz-code\";\nimport { ValueFunction } from \"./leibniz-defs\";\nimport { ASTNode, ASTNodeType, baseVectorId, kroneckerId, TreeNode } from \"./leibniz-parser\";\nimport { vector, matrix, Matrix } from \"./leibniz-tensor\";\n\nexport enum ValueTypeCode {\n    Scalar = 'scalar',\n    Vector = 'vector',\n    Quaternion = 'quaternion',\n    Matrix = 'matrix'\n};\n\nexport interface ScalarCode {\n    type: ValueTypeCode.Scalar;\n    code: ValueFunction<number>;\n}\n\nexport interface QuaternionCode {\n    type: ValueTypeCode.Quaternion;\n    code: ValueFunction<Quaternion>;\n}\n\nexport interface VectorCode {\n    type: ValueTypeCode.Vector;\n    rows: number;\n    code: ValueFunction<Matrix>;\n}\n\nexport interface MatrixCode {\n    type: ValueTypeCode.Matrix;\n    rows: number;\n    cols: number;\n    code: ValueFunction<Matrix>;\n}\n\n/**\n * \n */\nexport type ValueCode = ScalarCode | VectorCode | QuaternionCode | MatrixCode;\n\nexport function isScalarCode(x: ValueCode): x is ScalarCode {\n    return x.type === ValueTypeCode.Scalar;\n}\n\nexport function isQuaternionCode(x: ValueCode): x is QuaternionCode {\n    return x.type === ValueTypeCode.Quaternion;\n}\n\nexport function isVectorCode(x: ValueCode): x is VectorCode {\n    return x.type === ValueTypeCode.Vector;\n}\n\nexport function isMatrixCode(x: ValueCode): x is MatrixCode {\n    return x.type === ValueTypeCode.Matrix;\n}\n\n/**\n * \n * @param code \n */\nfunction newScalarCode(code: ValueFunction<number>): ScalarCode {\n    return { type: ValueTypeCode.Scalar, code };\n}\n\n/**\n * \n * @param code \n */\nexport function newQuaternionCode(code: ValueFunction<Quaternion>): QuaternionCode {\n    return { type: ValueTypeCode.Quaternion, code };\n}\n\n/**\n * \n * @param code \n * @param rows \n */\nexport function newVectorCode(code: ValueFunction<Matrix>, rows: number): VectorCode {\n    return { type: ValueTypeCode.Vector, rows, code };\n}\n\n/**\n * \n * @param code \n * @param rows \n * @param cols \n */\nexport function newMatrixCode(code: ValueFunction<Matrix>, rows: number, cols: number): MatrixCode {\n    return { type: ValueTypeCode.Matrix, rows, cols, code };\n}\n\n\n/**\n * \n * @param value \n */\nexport function numberCode(value: number): ScalarCode {\n    return newScalarCode(createConstantCode(value));\n}\n\n/**\n * \n * @param value \n */\nexport function quaternionCode(value: Quaternion): QuaternionCode {\n    return newQuaternionCode(createConstantCode(value));\n}\n\n/**\n * \n * @param value \n */\nexport function vectorCode(value: Matrix): VectorCode {\n    return newVectorCode(createConstantCode(value), value.rows);\n}\n\n/**\n * \n * @param value \n */\nexport function matrixCode(value: Matrix): MatrixCode {\n    return newMatrixCode(createConstantCode(value), value.rows, value.cols);\n}\n\n/**\n * \n * @param id \n */\nexport function refScalarCode(id: string): ScalarCode {\n    return newScalarCode(createNumberRefCode(id));\n}\n\n/**\n * \n * @param id \n */\nexport function refQuaternionCode(id: string): QuaternionCode {\n    return newQuaternionCode(createQuaternionRefCode(id));\n}\n\n/**\n * \n * @param id \n * @param n \n */\nexport function refVectorCode(id: string, n: number): VectorCode {\n    return newVectorCode(createMatrixRefCode(id), n);\n}\n\n/**\n * \n * @param id \n * @param n \n * @param m\n */\nexport function refMatrixCode(id: string, n: number, m: number): MatrixCode {\n    return newMatrixCode(createMatrixRefCode(id), n, m);\n}\n\nexport const ConstantCode: Record<string, ValueCode> = {\n    PI: numberCode(Math.PI),\n    e: numberCode(Math.E),\n    i: quaternionCode(new Quaternion(1, 0, 0, 0)),\n    j: quaternionCode(new Quaternion(0, 1, 0, 0)),\n    k: quaternionCode(new Quaternion(0, 0, 1, 0)),\n    ex: vectorCode(vector(1, 0, 0)),\n    ey: vectorCode(vector(0, 1, 0)),\n    ez: vectorCode(vector(0, 0, 1))\n}\n\nexport const ReservedReferences = ['dt'];\n\nexport const DefaultScalarCode = numberCode(0);\nexport const DefaultQuaternionCode = quaternionCode(Quaternion.Identity());\n\n/**\n * \n * @param n \n */\nexport function vector0Code(n: number) {\n    return vectorCode(vector.apply(undefined, _.range(0, n).map(() => 0)));\n}\n\n/**\n * \n * @param n \n * @param m \n */\nexport function matrix0Code(n: number, m: number) {\n    return matrixCode(\n        matrix(\n            _.range(0, n).map(i =>\n                _.range(0, m).map(j => 0)\n            )\n        )\n    );\n}\n\nexport interface CodeGenContext {\n    withTypeCode(arg: ValueCode): CodeGenContext;\n    addErrors(errors: string[]): CodeGenContext;\n    symbol(id: string): ValueCode | undefined;\n    typeCode: ValueCode;\n    errors: string[];\n}\n\nexport class BaseCodeGenContext implements CodeGenContext {\n    typeCode: ValueCode;\n    symbols: Record<string, ValueCode>;\n    errors: string[];\n\n    /**\n     * \n     * @param symbols \n     * @param typeCode \n     * @param errors \n     */\n    constructor(symbols: Record<string, ValueCode> = {}, typeCode: ValueCode = DefaultScalarCode, errors: string[] = []) {\n        this.typeCode = typeCode;\n        this.symbols = symbols;\n        this.errors = errors;\n    }\n\n    /**\n     * \n     * @param errors \n     */\n    addErrors(errors: string[]): BaseCodeGenContext {\n        return new BaseCodeGenContext(this.symbols, this.typeCode, _.concat(this.errors, errors));\n    }\n\n    /**\n     * \n     * @param arg \n     */\n    withTypeCode(arg: ValueCode): BaseCodeGenContext {\n        return new BaseCodeGenContext(this.symbols, arg, this.errors);\n    }\n\n    /**\n     * \n     * @param id \n     */\n    symbol(id: string): ValueCode | undefined {\n        return this.symbols[id];\n    }\n\n    /**\n     * \n     * @param id \n     * @param code \n     */\n    addSymbol(id: string, code: ValueCode): BaseCodeGenContext {\n        return this;\n    }\n}\n\n/**\n * \n * @param symbols \n */\nexport function createCodeGenContext(symbols: Record<string, ValueCode> = {}) {\n    return new BaseCodeGenContext(symbols);\n}\n\nconst FunctionOpMap: Record<string, (ctx: CodeGenContext) => CodeGenContext> = {\n    sin: createUnaryScalarCodeGen(Math.sin),\n    cos: createUnaryScalarCodeGen(Math.cos),\n    tan: createUnaryScalarCodeGen(Math.tan),\n    asin: createUnaryScalarCodeGen(Math.asin),\n    acos: createUnaryScalarCodeGen(Math.acos),\n    atan: createUnaryScalarCodeGen(Math.atan),\n    sinh: createUnaryScalarCodeGen(Math.sinh),\n    cosh: createUnaryScalarCodeGen(Math.cosh),\n    tanh: createUnaryScalarCodeGen(Math.tanh),\n    exp: createUnaryScalarCodeGen(Math.exp),\n    log: createUnaryScalarCodeGen(Math.log),\n    sqrt: createUnaryScalarCodeGen(Math.sqrt),\n    T: transposeCodeGen,\n    qrot: qrotCodeGen,\n    tr: trCodeGen,\n    n: nCodeGen,\n    cyl: cylCodeGen,\n    cyl1: cyl1CodeGen,\n    sphere: sphereCodeGen,\n    sphere1: sphere1CodeGen,\n    inv: invCodeGen,\n    det: detCodeGen,\n    min: minCodeGen,\n    max: maxCodeGen\n};\n\nexport const FunctionKeywords = _.keys(FunctionOpMap);\n\nconst UnaryOpMap: Record<string, (ctx: CodeGenContext) => CodeGenContext> = _.merge({\n    '+': (ctx: CodeGenContext) => ctx,\n    '-': negCodeGen,\n}, FunctionOpMap);\n\n/**\n * \n * @param code \n * @param value \n */\nexport function errorByCode(code: string, value: ValueCode): string[] {\n    switch (value.type) {\n        case ValueTypeCode.Scalar:\n            return [`${code}, scalar found`];\n        case ValueTypeCode.Quaternion:\n            return [`${code}, quaternion found`];\n        case ValueTypeCode.Vector:\n            return [`${code}, vector${value.rows} found`];\n        case ValueTypeCode.Matrix:\n            return [`${code}, matrix${value.rows}x${value.cols} found`];\n        default:\n            return [];\n    }\n}\n\nfunction assertRuleNode({ node, children }: TreeNode<ASTNode>, id: string, n?: number) {\n    if (node.type !== ASTNodeType.Rule) {\n        throw Error(`node ${node.type} !== ${ASTNodeType.Rule}`);\n    }\n    if (node.rule !== id) {\n        throw Error(`node ${node.rule} !== ${id}`);\n    }\n    if (n !== undefined && children.length !== n) {\n        throw Error(`number of children ${children.length} !== ${n}`);\n    }\n}\n\n/**\n * expression ::= sequence (expr, end-source)\n * @param ctx \n * @param param1 \n */\nexport function expressionCodeGen(ctx: CodeGenContext, node: TreeNode<ASTNode>): CodeGenContext {\n    assertRuleNode(node, 'expression', 2);\n    return exprCodeGen(ctx, node.children[0]);\n}\n\n/**\n * expr ::= sequence (sum, expr-suffix*)\n * @param ctx \n * @param param1 \n */\nfunction exprCodeGen(ctx: CodeGenContext, node: TreeNode<ASTNode>): CodeGenContext {\n    assertRuleNode(node, 'expr', 2);\n    const sumCtx = sumCodeGen(ctx, node.children[0]);\n\n    return exprSuffixCodeGen(sumCtx, node.children[1]);\n}\n\n/**\n * expr-suffix* ::= repeat (expr-suffix ::= sequence ( , sum))\n * @param ctx \n * @param node \n */\nfunction exprSuffixCodeGen(ctx: CodeGenContext, node: TreeNode<ASTNode>): CodeGenContext {\n    assertRuleNode(node, 'expr-suffix*');\n\n    // Check type of base\n    if (node.children.length === 0) {\n        return ctx;\n    }\n\n    const result = _(node.children).reduce((sum1Ctx, node) => {\n        // List of seq ast with ops and factor\n        assertRuleNode(node, 'expr-suffix', 2);\n        const sum2Ctx = sumCodeGen(sum1Ctx, node.children[1]);\n        const opsNode = node.children[0].node;\n        if (opsNode.type !== ASTNodeType.Sym) {\n            throw new Error(`unexpected node type ${opsNode.type}`);\n        }\n        return concatCodeGen(sum2Ctx, sum1Ctx.typeCode, sum2Ctx.typeCode);\n    }, ctx);\n    return result;\n}\n\n/**\n * \n * @param aCtx \n * @param bCtx \n */\nfunction concatCodeGen(ctx: CodeGenContext, a: ValueCode, b: ValueCode): CodeGenContext {\n    if (isScalarCode(a)) {\n        switch (b.type) {\n            case ValueTypeCode.Scalar:\n                return ctx.withTypeCode(newVectorCode(createConcatSS(a.code, b.code), 2));\n            case ValueTypeCode.Vector:\n                return ctx.withTypeCode(newVectorCode(createInsertCode(a.code, b.code), b.rows + 1));\n            case ValueTypeCode.Quaternion:\n            case ValueTypeCode.Matrix:\n                return ctx.addErrors(errorByCode('scalar or vector expected', b));\n        }\n    }\n    if (isQuaternionCode(a)) {\n        return ctx.addErrors(errorByCode('quaternion cannot be concatenated', b));\n    }\n    if (isVectorCode(a)) {\n        switch (b.type) {\n            case ValueTypeCode.Scalar:\n                return ctx.withTypeCode(newVectorCode(createAppendScalarCode(a.code, b.code), a.rows + 1));\n            case ValueTypeCode.Quaternion:\n                return ctx.addErrors(errorByCode('scalar or vector expected', b));\n            case ValueTypeCode.Vector: {\n                const ac = a.rows < b.rows ? createResizeCode(a.code, b.rows, 1) : a.code;\n                const bc = b.rows < a.rows ? createResizeCode(b.code, a.rows, 1) : b.code;\n                return ctx.withTypeCode(\n                    newMatrixCode(\n                        createAppendCode(ac, bc),\n                        Math.max(a.rows, b.rows),\n                        2));\n            }\n            case ValueTypeCode.Matrix: {\n                const ac = a.rows < b.rows ? createResizeCode(a.code, b.rows, 1) : a.code;\n                const bc = b.rows < a.rows ? createResizeCode(b.code, a.rows, b.cols) : b.code;\n                return ctx.withTypeCode(\n                    newMatrixCode(\n                        createAppendCode(ac, bc),\n                        Math.max(a.rows, b.rows),\n                        b.cols + 1));\n            }\n        }\n    }\n    if (isMatrixCode(a)) {\n        switch (b.type) {\n            case ValueTypeCode.Scalar:\n            case ValueTypeCode.Quaternion:\n                return ctx.addErrors(errorByCode('vector or matrix expected', b));\n            case ValueTypeCode.Vector: {\n                const ac = a.rows < b.rows ? createResizeCode(a.code, b.rows, a.cols) : a.code;\n                const bc = b.rows < a.rows ? createResizeCode(b.code, a.rows, 1) : b.code;\n                return ctx.withTypeCode(\n                    newMatrixCode(\n                        createAppendCode(ac, bc),\n                        Math.max(a.rows, b.rows),\n                        a.cols + 1));\n            }\n            case ValueTypeCode.Matrix: {\n                const ac = a.rows < b.rows ? createResizeCode(a.code, b.rows, a.cols) : a.code;\n                const bc = b.rows < a.rows ? createResizeCode(b.code, a.rows, b.cols) : b.code;\n                return ctx.withTypeCode(\n                    newMatrixCode(\n                        createAppendCode(ac, bc),\n                        Math.max(a.rows, b.rows),\n                        a.cols + b.cols));\n            }\n        }\n    }\n    throw new Error(`invalid branch ${b.type}`);\n}\n\n/**\n * sum ::= sequence (factor, sum-suffix*)\n * @param ctx \n * @param param1 \n */\nfunction sumCodeGen(ctx: CodeGenContext, node: TreeNode<ASTNode>): CodeGenContext {\n    assertRuleNode(node, 'sum', 2);\n    const sumCtx = factorCodeGen(ctx, node.children[0]);\n\n    return sumSuffix(sumCtx, node.children[1]);\n}\n\n/**\n * sum-suffix* ::= repeat (sum-suffix ::= sequence ( + | - ) factor))\n * @param ctx \n * @param node \n */\nfunction sumSuffix(ctx: CodeGenContext, node: TreeNode<ASTNode>): CodeGenContext {\n    assertRuleNode(node, 'sum-suffix*');\n\n    // Check type of base\n    if (node.children.length === 0) {\n        return ctx;\n    }\n\n    const result = _(node.children).reduce((factor1Ctx, node) => {\n        // List of seq ast with ops and factor\n        assertRuleNode(node, 'sum-suffix', 2);\n        const factor2Ctx = factorCodeGen(factor1Ctx, node.children[1]);\n        const opsNode = node.children[0].node;\n        if (opsNode.type !== ASTNodeType.Sym) {\n            throw new Error(`unexpected node type ${opsNode.type}`);\n        }\n        switch (opsNode.symbol) {\n            case '+':\n                return addCodeGen(factor2Ctx, factor1Ctx.typeCode, factor2Ctx.typeCode);\n            case '-':\n                return subCodeGen(factor2Ctx, factor1Ctx.typeCode, factor2Ctx.typeCode);\n            default:\n                throw new Error(`unexpected symbol ${opsNode.symbol}`);\n        }\n    }, ctx);\n    return result;\n}\n\n/**\n * \n * @param aCtx \n * @param bCtx \n */\nfunction addCodeGen(ctx: CodeGenContext, a: ValueCode, b: ValueCode): CodeGenContext {\n    if (isScalarCode(a)) {\n        switch (b.type) {\n            case ValueTypeCode.Scalar:\n                return ctx.withTypeCode(newScalarCode(createAddSSCode(a.code, b.code)));\n            case ValueTypeCode.Quaternion:\n                return ctx.withTypeCode(newQuaternionCode(createAddSQCode(a.code, b.code)));\n            case ValueTypeCode.Vector:\n            case ValueTypeCode.Matrix:\n                return ctx.addErrors(errorByCode('scalar or quaternion expected', b));\n        }\n    }\n    if (isQuaternionCode(a)) {\n        switch (b.type) {\n            case ValueTypeCode.Scalar:\n                return ctx.withTypeCode(newQuaternionCode(createAddSQCode(b.code, a.code)));\n            case ValueTypeCode.Quaternion:\n                return ctx.withTypeCode(newQuaternionCode(createAddQQCode(a.code, b.code)));\n            case ValueTypeCode.Vector:\n            case ValueTypeCode.Matrix:\n                return ctx.addErrors(errorByCode('scalar or quaternion expected', b));\n        }\n    }\n    if (isVectorCode(a)) {\n        if (isVectorCode(b)) {\n            const ac = a.rows < b.rows ? createResizeCode(a.code, b.rows, 1) : a.code;\n            const bc = b.rows < a.rows ? createResizeCode(b.code, a.rows, 1) : b.code;\n            return ctx.withTypeCode(newVectorCode(\n                createAddMMCode(ac, bc),\n                Math.max(a.rows, b.rows)\n            ));\n        }\n        return ctx.addErrors(errorByCode(`vector expected`, b));\n    }\n    if (isMatrixCode(a)) {\n        if (isMatrixCode(b)) {\n            const n = Math.max(a.rows, b.rows);\n            const m = Math.max(a.cols, b.cols);\n            const ac = a.rows < n || a.cols < m ? createResizeCode(a.code, n, m) : a.code;\n            const bc = b.rows < n || b.cols < m ? createResizeCode(b.code, n, m) : b.code;\n            return ctx.withTypeCode(newMatrixCode(\n                createAddMMCode(ac, bc), n, m\n            ));\n        }\n        return ctx.addErrors(errorByCode(`matrix expected`, b));\n    }\n    throw new Error('Invalid branch');\n}\n\n/**\n * \n * @param aCtx \n * @param bCtx \n */\nfunction subCodeGen(ctx: CodeGenContext, a: ValueCode, b: ValueCode): CodeGenContext {\n    if (isScalarCode(a)) {\n        switch (b.type) {\n            case ValueTypeCode.Scalar:\n                return ctx.withTypeCode(newScalarCode(createSubSSCode(a.code, b.code)));\n            case ValueTypeCode.Quaternion:\n                return ctx.withTypeCode(newQuaternionCode(createSubSQCode(a.code, b.code)));\n            case ValueTypeCode.Vector:\n            case ValueTypeCode.Matrix:\n                return ctx.addErrors(errorByCode('scalar or quaternion expected', b));\n        }\n    }\n    if (isQuaternionCode(a)) {\n        switch (b.type) {\n            case ValueTypeCode.Scalar:\n                return ctx.withTypeCode(newQuaternionCode(createSubQSCode(a.code, b.code)));\n            case ValueTypeCode.Quaternion:\n                return ctx.withTypeCode(newQuaternionCode(createSubQQCode(a.code, b.code)));\n            case ValueTypeCode.Vector:\n            case ValueTypeCode.Matrix:\n                return ctx.addErrors(errorByCode('scalar or quaternion expected', b));\n        }\n    }\n    if (isVectorCode(a)) {\n        if (isVectorCode(b)) {\n            const n = Math.max(a.rows, b.rows);\n            const ac = a.rows < n ? createResizeCode(a.code, n, 1) : a.code;\n            const bc = b.rows < n ? createResizeCode(b.code, n, 1) : b.code;\n            return ctx.withTypeCode(newVectorCode(\n                createSubMMCode(ac, bc), n\n            ));\n        }\n        return ctx.addErrors(errorByCode(`vector expected`, b));\n    }\n    if (isMatrixCode(a)) {\n        if (isMatrixCode(b)) {\n            const n = Math.max(a.rows, b.rows);\n            const m = Math.max(a.cols, b.cols);\n            const ac = a.rows < n || a.cols < m ? createResizeCode(a.code, n, m) : a.code;\n            const bc = b.rows < n || b.cols < m ? createResizeCode(b.code, n, m) : b.code;\n            return ctx.withTypeCode(newMatrixCode(\n                createSubMMCode(ac, bc), n, m));\n        }\n        return ctx.addErrors(errorByCode(`matrix expected`, b));\n    }\n    throw new Error('Invalid branch');\n}\n\n/**\n * factor ::= sequence (unary, factor-suffix*)\n * @param ctx \n * @param param1 \n */\nfunction factorCodeGen(ctx: CodeGenContext, node: TreeNode<ASTNode>): CodeGenContext {\n    assertRuleNode(node, 'factor', 2);\n    const factorCtx = unaryCodeGen(ctx, node.children[0]);\n\n    return factorSuffixCodeGen(factorCtx, node.children[1]);\n}\n\n/**\n * factor-suffix* ::= repeat (factor-suffix ::= sequence ( * | / ) unary))\n * @param ctx \n * @param node \n */\nfunction factorSuffixCodeGen(ctx: CodeGenContext, node: TreeNode<ASTNode>): CodeGenContext {\n    assertRuleNode(node, 'factor-suffix*');\n\n    // Check type of base\n    if (node.children.length === 0) {\n        return ctx;\n    }\n\n    const result = _(node.children).reduce((unary1Ctx, node) => {\n        // List of seq ast with ops and factor\n        assertRuleNode(node, 'factor-suffix', 2);\n        const unary2Ctx = unaryCodeGen(unary1Ctx, node.children[1]);\n        const opsNode = node.children[0].node;\n        if (opsNode.type !== ASTNodeType.Sym) {\n            throw new Error(`unexpected node type ${opsNode.type}`);\n        }\n        switch (opsNode.symbol) {\n            case '*':\n                return mulCodeGen(unary2Ctx, unary1Ctx.typeCode, unary2Ctx.typeCode);\n            case '/':\n                return divCodeGen(unary2Ctx, unary1Ctx.typeCode, unary2Ctx.typeCode);\n            default:\n                throw new Error(`unexpected symbol ${opsNode.symbol}`);\n        }\n    }, ctx);\n    return result;\n}\n\n/**\n * \n * @param aCtx \n * @param bCtx \n */\nfunction mulCodeGen(ctx: CodeGenContext, a: ValueCode, b: ValueCode): CodeGenContext {\n    if (isScalarCode(a)) {\n        switch (b.type) {\n            case ValueTypeCode.Scalar:\n                return ctx.withTypeCode(newScalarCode(createMulSSCode(a.code, b.code)));\n            case ValueTypeCode.Quaternion:\n                return ctx.withTypeCode(newQuaternionCode(createMulSQCode(a.code, b.code)));\n            case ValueTypeCode.Vector:\n                return ctx.withTypeCode(newVectorCode(\n                    createMulSMCode(a.code, b.code),\n                    b.rows\n                ));\n            case ValueTypeCode.Matrix:\n                return ctx.withTypeCode(newMatrixCode(\n                    createMulSMCode(a.code, b.code),\n                    b.rows,\n                    b.cols\n                ));\n        }\n    }\n    if (isQuaternionCode(a)) {\n        switch (b.type) {\n            case ValueTypeCode.Scalar:\n                return ctx.withTypeCode(newQuaternionCode(createMulSQCode(b.code, a.code)));\n            case ValueTypeCode.Quaternion:\n                return ctx.withTypeCode(newQuaternionCode(createMulQQCode(a.code, b.code)));\n            case ValueTypeCode.Vector:\n            case ValueTypeCode.Matrix:\n                return ctx.addErrors(errorByCode('scalar or quaternion expected', b));\n        }\n    }\n    if (isVectorCode(a)) {\n        switch (b.type) {\n            case ValueTypeCode.Scalar:\n                return ctx.withTypeCode(newVectorCode(\n                    createMulSMCode(b.code, a.code),\n                    a.rows\n                ));\n            case ValueTypeCode.Vector: {\n                const n = Math.min(a.rows, b.rows);\n                const ac = a.rows > n ? createResizeCode(a.code, n, 1) : a.code;\n                const bc = b.rows > n ? createResizeCode(b.code, n, 1) : b.code;\n                return ctx.withTypeCode(newScalarCode(createScalarMulCode(ac, bc)));\n            }\n\n        }\n        return ctx.addErrors(errorByCode('scalar expected', b));\n    }\n    if (isMatrixCode(a)) {\n        switch (b.type) {\n            case ValueTypeCode.Scalar:\n                return ctx.withTypeCode(newMatrixCode(\n                    createMulSMCode(b.code, a.code),\n                    a.rows,\n                    a.cols\n                ));\n            case ValueTypeCode.Vector: {\n                const n = Math.min(a.cols, b.rows);\n                const ac = a.cols > n ? createResizeCode(a.code, a.rows, n) : a.code;\n                const bc = b.rows > n ? createResizeCode(b.code, n, 1) : b.code;\n                return ctx.withTypeCode(newVectorCode(\n                    createMulMMCode(ac, bc),\n                    a.rows\n                ));\n            }\n            case ValueTypeCode.Quaternion:\n                return ctx.addErrors(errorByCode('not quaternion expected', b));\n            case ValueTypeCode.Matrix: {\n                const n = Math.min(a.cols, b.rows);\n                const ac = a.cols > n ? createResizeCode(a.code, a.rows, n) : a.code;\n                const bc = b.rows > n ? createResizeCode(b.code, n, b.cols) : b.code;\n                return ctx.withTypeCode(newMatrixCode(\n                    createMulMMCode(ac, bc),\n                    a.rows,\n                    b.cols\n                ));\n            }\n        }\n    }\n    throw new Error('Invalid branch');\n}\n\n/**\n * \n * @param aCtx \n * @param bCtx \n */\nfunction divCodeGen(ctx: CodeGenContext, a: ValueCode, b: ValueCode): CodeGenContext {\n    if (isScalarCode(a)) {\n        switch (b.type) {\n            case ValueTypeCode.Scalar:\n                return ctx.withTypeCode(newScalarCode(createDivSSCode(a.code, b.code)));\n            case ValueTypeCode.Quaternion:\n                return ctx.withTypeCode(newQuaternionCode(createDivSQCode(a.code, b.code)));\n            case ValueTypeCode.Vector:\n            case ValueTypeCode.Matrix:\n                return ctx.addErrors(errorByCode('scalar or quaternion expected', b));\n        }\n    }\n    if (isQuaternionCode(a)) {\n        switch (b.type) {\n            case ValueTypeCode.Scalar:\n                return ctx.withTypeCode(newQuaternionCode(createDivQSCode(a.code, b.code)));\n            case ValueTypeCode.Quaternion:\n                return ctx.withTypeCode(newQuaternionCode(createDivQQCode(a.code, b.code)));\n            case ValueTypeCode.Vector:\n            case ValueTypeCode.Matrix:\n                return ctx.addErrors(errorByCode('scalar or quaternion expected', b));\n        }\n    }\n    if (isVectorCode(a)) {\n        if (isScalarCode(b)) {\n            return ctx.withTypeCode(newVectorCode(\n                createDivMSCode(a.code, b.code),\n                a.rows\n            ));\n        }\n        return ctx.addErrors(errorByCode('scalar expected', b));\n    }\n    if (isMatrixCode(a)) {\n        switch (b.type) {\n            case ValueTypeCode.Scalar:\n                return ctx.withTypeCode(newMatrixCode(\n                    createDivMSCode(a.code, b.code),\n                    a.rows,\n                    a.cols\n                ));\n            case ValueTypeCode.Vector:\n            case ValueTypeCode.Quaternion:\n                return ctx.addErrors(errorByCode(`scalar or matrix expected`, b));\n            case ValueTypeCode.Matrix:\n                const n = Math.min(a.cols, b.rows, b.cols);\n                const ac = a.cols > n ? createResizeCode(a.code, a.rows, n) : a.code;\n                const bc = b.rows > n || b.cols > n ? createResizeCode(b.code, n, n) : b.code;\n                return ctx.withTypeCode(newMatrixCode(\n                    createDivMMCode(ac, bc), a.rows, n\n                ));\n        }\n    }\n    throw new Error('Invalid branch');\n}\n\n/**\n * unary ::= sequence (unary-op*, pow)\n * @param ctx \n * @param param1 \n */\nfunction unaryCodeGen(ctx: CodeGenContext, node: TreeNode<ASTNode>): CodeGenContext {\n    assertRuleNode(node, 'unary', 2);\n    const unaryCtx = powCodeGen(ctx, node.children[1]);\n    return unaryOpCodeGen(unaryCtx, node.children[0]);\n}\n\n/**\n * unary-op* ::= repeat ( unary-op:= <list of unary operator as idAST or symbolAST> )\n * @param ctx \n * @param node \n */\nfunction unaryOpCodeGen(ctx: CodeGenContext, node: TreeNode<ASTNode>): CodeGenContext {\n    assertRuleNode(node, 'unary-op*');\n    // Check type of base\n    if (node.children.length === 0) {\n        return ctx;\n    }\n    const result = _(node.children).reduceRight((locCtx, node) => {\n        var tok: string;\n        switch (node.node.type) {\n            case ASTNodeType.Id:\n                tok = node.node.id;\n                break;\n            case ASTNodeType.Sym:\n                tok = node.node.symbol;\n                break;\n            default:\n                throw new Error(`unexpected ${node.node.type}`);\n        }\n        const op = UnaryOpMap[tok];\n        if (!op) {\n            throw new Error(`${tok} is not an operator`);\n        }\n        return op(locCtx);\n    }, ctx);\n    return result;\n}\n\n/**\n * \n * @param ctx \n */\nfunction negCodeGen(ctx: CodeGenContext): CodeGenContext {\n    const { typeCode } = ctx;\n    if (isScalarCode(typeCode)) {\n        return ctx.withTypeCode(newScalarCode(createNegScalarCode(typeCode.code)));\n    }\n    if (isQuaternionCode(typeCode)) {\n        return ctx.withTypeCode(newQuaternionCode(createNegQuaternionCode(typeCode.code)));\n    }\n    if (isVectorCode(typeCode)) {\n        return ctx.withTypeCode(newVectorCode(createNegMatrixCode(typeCode.code), typeCode.rows));\n    }\n    return ctx.withTypeCode(newMatrixCode(createNegMatrixCode(typeCode.code), typeCode.rows, typeCode.cols));\n}\n\n/**\n * \n * @param f \n */\nfunction createUnaryScalarCodeGen(f: (arg: number) => number): (ctx: CodeGenContext) => CodeGenContext {\n    return (ctx: CodeGenContext): CodeGenContext => {\n        const { typeCode } = ctx;\n        if (!isScalarCode(typeCode)) {\n            return ctx.addErrors(errorByCode('scalar expected', typeCode));\n        }\n        return ctx.withTypeCode(\n            newScalarCode(\n                createScalarFunctionCode(typeCode.code, f)));\n    };\n}\n\n/**\n * \n * @param ctx \n */\nfunction transposeCodeGen(ctx: CodeGenContext): CodeGenContext {\n    const { typeCode } = ctx;\n    switch (typeCode.type) {\n        case ValueTypeCode.Scalar:\n        case ValueTypeCode.Quaternion:\n            return ctx;\n        case ValueTypeCode.Vector:\n            return ctx.withTypeCode(\n                newMatrixCode(\n                    createTransposeCode(typeCode.code), 1, typeCode.rows\n                ));\n        case ValueTypeCode.Matrix:\n            return ctx.withTypeCode(\n                newMatrixCode(\n                    createTransposeCode(typeCode.code), typeCode.cols, typeCode.rows\n                ));\n    }\n}\n\n/**\n * \n * @param ctx \n */\nfunction qrotCodeGen(ctx: CodeGenContext): CodeGenContext {\n    const { typeCode } = ctx;\n    if (!isVectorCode(typeCode) || typeCode.rows !== 3) {\n        return ctx.addErrors(errorByCode('vector3 expected', typeCode));\n    }\n    return ctx.withTypeCode(\n        newQuaternionCode(\n            createQRotCode(typeCode.code)));\n}\n\n/**\n * \n * @param ctx \n */\nfunction trCodeGen(ctx: CodeGenContext): CodeGenContext {\n    const { typeCode } = ctx;\n    if (!isMatrixCode(typeCode) || typeCode.rows !== typeCode.cols) {\n        return ctx.addErrors(errorByCode('square matrix expected', typeCode));\n    }\n    return ctx.withTypeCode(\n        newScalarCode(createTrCode(typeCode.code)));\n}\n\n/**\n * \n * @param ctx \n */\nfunction nCodeGen(ctx: CodeGenContext): CodeGenContext {\n    const { typeCode } = ctx;\n    if (!isVectorCode(typeCode)) {\n        return ctx.addErrors(errorByCode('vector expected', typeCode));\n    }\n    return ctx.withTypeCode(\n        newVectorCode(\n            createNormalCode(typeCode.code),\n            typeCode.rows));\n}\n\n/**\n * \n * @param ctx \n */\nfunction cylCodeGen(ctx: CodeGenContext): CodeGenContext {\n    const { typeCode } = ctx;\n    if (!isVectorCode(typeCode) || typeCode.rows !== 3) {\n        return ctx.addErrors(errorByCode('vector3 expected', typeCode));\n    }\n    return ctx.withTypeCode(\n        newVectorCode(\n            createCylCode(typeCode.code), 3));\n}\n\n/**\n * \n * @param ctx \n */\nfunction cyl1CodeGen(ctx: CodeGenContext): CodeGenContext {\n    const { typeCode } = ctx;\n    if (!isVectorCode(typeCode) || typeCode.rows !== 3) {\n        return ctx.addErrors(errorByCode('vector3 expected', typeCode));\n    }\n    return ctx.withTypeCode(\n        newMatrixCode(\n            createCyl1Code(typeCode.code), 3, 3));\n}\n\n/**\n * \n * @param ctx \n */\nfunction sphereCodeGen(ctx: CodeGenContext): CodeGenContext {\n    const { typeCode } = ctx;\n    if (!isVectorCode(typeCode) || typeCode.rows !== 3) {\n        return ctx.addErrors(errorByCode('vector3 expected', typeCode));\n    }\n    return ctx.withTypeCode(\n        newVectorCode(\n            createSphereCode(typeCode.code), 3));\n}\n\n/**\n * \n * @param ctx \n */\nfunction sphere1CodeGen(ctx: CodeGenContext): CodeGenContext {\n    const { typeCode } = ctx;\n    if (!isVectorCode(typeCode) || typeCode.rows !== 3) {\n        return ctx.addErrors(errorByCode('vector3 expected', typeCode));\n    }\n    return ctx.withTypeCode(\n        newMatrixCode(\n            createSphere1Code(typeCode.code), 3, 3));\n}\n\n/**\n * \n * @param ctx \n */\nfunction invCodeGen(ctx: CodeGenContext): CodeGenContext {\n    const { typeCode } = ctx;\n    switch (typeCode.type) {\n        case ValueTypeCode.Scalar:\n            return ctx.withTypeCode(newScalarCode(createScalarInvCode(typeCode.code)));\n        case ValueTypeCode.Quaternion:\n            return ctx.withTypeCode(newQuaternionCode(createQuaternionInvCode(typeCode.code)));\n        case ValueTypeCode.Vector:\n            return ctx.addErrors(errorByCode('not vector expected', typeCode));\n        case ValueTypeCode.Matrix:\n            if (typeCode.cols !== typeCode.rows) {\n                return ctx.addErrors(errorByCode('square matrix expected', typeCode));\n            }\n            return ctx.withTypeCode(\n                newMatrixCode(\n                    createMatrixInvCode(typeCode.code),\n                    typeCode.rows,\n                    typeCode.cols));\n        default:\n            throw new Error('Inconsistency branch')\n    }\n}\n\n/**\n * \n * @param ctx \n */\nfunction detCodeGen(ctx: CodeGenContext): CodeGenContext {\n    const { typeCode } = ctx;\n    switch (typeCode.type) {\n        case ValueTypeCode.Scalar:\n        case ValueTypeCode.Quaternion:\n            return ctx;\n        case ValueTypeCode.Vector:\n            return ctx.addErrors(errorByCode('square matrix expected', typeCode));\n        case ValueTypeCode.Matrix:\n            if (typeCode.cols !== typeCode.rows) {\n                return ctx.addErrors(errorByCode('square matrix expected', typeCode));\n            }\n            return ctx.withTypeCode(newScalarCode(createDetCode(typeCode.code)));\n        default:\n            throw new Error('Inconsistency branch')\n    }\n}\n\n/**\n * \n * @param ctx \n */\nfunction maxCodeGen(ctx: CodeGenContext): CodeGenContext {\n    const { typeCode } = ctx;\n    switch (typeCode.type) {\n        case ValueTypeCode.Scalar:\n        case ValueTypeCode.Quaternion:\n            return ctx.addErrors(errorByCode('vector or matrix expected', typeCode));\n        case ValueTypeCode.Vector:\n        case ValueTypeCode.Matrix:\n            return ctx.withTypeCode(newScalarCode(createMaxCode(typeCode.code)));\n        default:\n            throw new Error('Inconsistency branch')\n    }\n}\n\n/**\n * \n * @param ctx \n */\nfunction minCodeGen(ctx: CodeGenContext): CodeGenContext {\n    const { typeCode } = ctx;\n    switch (typeCode.type) {\n        case ValueTypeCode.Scalar:\n        case ValueTypeCode.Quaternion:\n            return ctx.addErrors(errorByCode('vector or matrix expected', typeCode));\n        case ValueTypeCode.Vector:\n        case ValueTypeCode.Matrix:\n            return ctx.withTypeCode(newScalarCode(createMinCode(typeCode.code)));\n        default:\n            throw new Error('Inconsistency branch')\n    }\n}\n\n/**\n * pow ::= sequence (terminal, pow-suffix*)\n * @param ctx \n * @param ast \n */\nfunction powCodeGen(ctx: CodeGenContext, node: TreeNode<ASTNode>): CodeGenContext {\n    assertRuleNode(node, 'pow', 2);\n    const baseCtx = terminalCodeGen(ctx, node.children[0]);\n    return powSuffix(baseCtx, node.children[1]);\n}\n\n/**\n * pow-suffix* ::= repeat ( pow-suffix ::= sequence( ^, terminal))\n * @param ctx \n * @param suffix \n */\nfunction powSuffix(ctx: CodeGenContext, node: TreeNode<ASTNode>): CodeGenContext {\n    assertRuleNode(node, 'pow-suffix*');\n\n    // Check type of base\n    if (node.children.length === 0) {\n        return ctx;\n    }\n    const baseCode = ctx.typeCode;\n    if (!isScalarCode(baseCode)) {\n        return ctx.addErrors(errorByCode(`scalar expected`, baseCode));\n    }\n    const result = _(node.children).reduce((baseCtx, node) => {\n        // List of seq ast with exponents\n        assertRuleNode(node, 'pow-suffix', 2);\n        const baseCode = baseCtx.typeCode;\n        if (!isScalarCode(baseCode)) {\n            throw new Error('invalid branch');\n        }\n\n        const expCtx = terminalCodeGen(baseCtx, node.children[1]);\n        const expCode = expCtx.typeCode;\n        if (!isScalarCode(expCode)) {\n            return expCtx.addErrors(errorByCode(`scalar expected`, expCode));\n        }\n        return expCtx.withTypeCode(\n            newScalarCode(\n                createPowCode(baseCode.code, expCode.code)));\n    }, ctx);\n    return result;\n}\n\n/**\n * terminal := number, id, priority\n * @param ctx \n * @param ast \n */\nfunction terminalCodeGen(ctx: CodeGenContext, ast: TreeNode<ASTNode>): CodeGenContext {\n    const { node } = ast;\n    switch (node.type) {\n        case ASTNodeType.Number:\n            return ctx.withTypeCode(numberCode(parseFloat(node.value)));\n        case ASTNodeType.Id:\n            return idCodeGen(ctx, node.id);\n        case ASTNodeType.Rule:\n            switch (node.rule) {\n                case 'bracket':\n                    return braketCodeGen(ctx, ast);\n                case 'module':\n                    return moduleCodeGen(ctx, ast);\n            }\n    }\n    throw new Error(`invalid tree at ${node.type}`);\n}\n\n/**\n * barcket ::= sequence( ( expr ) )\n * @param ctx \n * @param id \n */\nfunction braketCodeGen(ctx: CodeGenContext, ast: TreeNode<ASTNode>): CodeGenContext {\n    assertRuleNode(ast, 'bracket', 3);\n    return exprCodeGen(ctx, ast.children[1]);\n}\n\n/**\n * module ::= sequence (| expr |)\n * @param ctx \n * @param id \n */\nfunction moduleCodeGen(ctx: CodeGenContext, ast: TreeNode<ASTNode>): CodeGenContext {\n    assertRuleNode(ast, 'module', 3);\n    const modCtx = exprCodeGen(ctx, ast.children[1]);\n    const { typeCode } = modCtx;\n    switch (typeCode.type) {\n        case ValueTypeCode.Scalar:\n            return modCtx.withTypeCode(newScalarCode(createModScalarCode(typeCode.code)));\n        case ValueTypeCode.Quaternion:\n            return modCtx.withTypeCode(newScalarCode(createModQuaternionCode(typeCode.code)));\n        case ValueTypeCode.Vector:\n            return modCtx.withTypeCode(newScalarCode(createModVectorCode(typeCode.code)));\n        case ValueTypeCode.Matrix:\n            return modCtx.addErrors(errorByCode('not matrix expected', typeCode));\n    }\n}\n\n/**\n * \n * @param ctx \n * @param id \n */\nfunction idCodeGen(ctx: CodeGenContext, id: string): CodeGenContext {\n    // Test for predefined references\n    if (ReservedReferences.indexOf(id) >= 0) {\n        return ctx.withTypeCode(refScalarCode(id));\n    }\n\n    // Test for constant keywords\n    const k = ConstantCode[id];\n    if (k) {\n        return ctx.withTypeCode(k);\n    }\n    // Test for base vector keywords\n    const vn = baseVectorId(id);\n    if (vn) {\n        const n = parseInt(vn);\n        const values = _.range(0, n + 1).map(i => i === n ? 1 : 0) as number[];\n        return ctx.withTypeCode(vectorCode(vector.apply(undefined, values)));\n    }\n    // Test for kronecker keywords\n    const kn = kroneckerId(id);\n    if (kn) {\n        const n = parseInt(kn);\n        const values = _.range(0, n).map(i =>\n            _.range(0, n).map(j =>\n                i === j ? 1 : 0) as number[]);\n        return ctx.withTypeCode(matrixCode(matrix(values)));\n    }\n    // Resolve id\n    const symbol = ctx.symbol(id);\n    return ctx.withTypeCode(symbol ?? DefaultScalarCode);\n}\n","import { Quaternion } from \"babylonjs\";\nimport { InternalStatus, ValueFunction } from \"./leibniz-defs\";\nimport { AnyValue, isMatrix, isNumber, isQuaternion, Matrix, vector } from \"./leibniz-tensor\";\n\n/**\n * \n */\nfunction isTracing() {\n    return false;\n}\n\nfunction tracing(f: () => string) {\n    if (isTracing()) { console.log(f()); }\n}\n\n/**\n * \n * @param value \n */\nexport function createConstantCode<T extends AnyValue>(value: T): ValueFunction<T> {\n    return (status: InternalStatus) => {\n        tracing(() => `get value ${value}`);\n        return value;\n    };\n}\n\n/**\n * \n * @param id \n */\nexport function createNumberRefCode(id: string): ValueFunction<number> {\n    return (status: InternalStatus) => {\n        const value = status[id];\n        if (value === undefined) {\n            throw new Error(`Reference ${id} not defined`);\n        }\n        if (!isNumber(value)) {\n            throw new Error(`Reference ${id} is not a number`);\n        }\n        tracing(() => `get ${id} = ${value}`);\n        return value;\n    };\n}\n\n/**\n * \n * @param id \n */\nexport function createQuaternionRefCode(id: string): ValueFunction<Quaternion> {\n    return (status: InternalStatus) => {\n        const value = status[id];\n        if (value === undefined) {\n            throw new Error(`Reference ${id} not defined`);\n        }\n        if (!isQuaternion(value)) {\n            throw new Error(`Reference ${id} is not a number`);\n        }\n        tracing(() => `get ${id} = ${value}`);\n        return value;\n    };\n}\n\nexport function createMatrixRefCode(id: string): ValueFunction<Matrix> {\n    return (status: InternalStatus) => {\n        const value = status[id];\n        if (value === undefined) {\n            throw new Error(`Reference ${id} not defined`);\n        }\n        if (!isMatrix(value)) {\n            throw new Error(`Reference ${id} is not a number`);\n        }\n        tracing(() => `get ${id} = ${value}`);\n        return value;\n    };\n}\n\n/**\n * \n * @param base \n * @param exp \n */\nexport function createPowCode(base: ValueFunction<number>, exp: ValueFunction<number>): ValueFunction<number> {\n    return (ctx: Record<string, AnyValue>) => {\n        const b = base(ctx);\n        const e = exp(ctx)\n        const result = Math.pow(b, e);\n        tracing(() => `pow ${b} by ${e} =  ${result}`);\n        return result;\n    }\n}\n\n/**\n * \n * @param base \n */\nexport function createNegScalarCode(base: ValueFunction<number>): ValueFunction<number> {\n    return (ctx: Record<string, AnyValue>) => {\n        const x = base(ctx);\n        const result = -x;\n        tracing(() => `neg ${x} = ${result}`);\n        return result;\n    }\n}\n\n/**\n * \n * @param base \n */\nexport function createNegQuaternionCode(base: ValueFunction<Quaternion>): ValueFunction<Quaternion> {\n    return (ctx: Record<string, AnyValue>) => {\n        const x = base(ctx)\n        const result = Quaternion.Zero().subtract(x);\n        tracing(() => `neg ${x} = ${result}`);\n        return result;\n    }\n}\n\n/**\n * \n * @param base \n */\nexport function createNegMatrixCode(base: ValueFunction<Matrix>): ValueFunction<Matrix> {\n    return (ctx: Record<string, AnyValue>) => {\n        const x = base(ctx)\n        const result = x.negate();\n        tracing(() => `neg ${x} = ${result}`);\n        return result;\n    }\n}\n\n/**\n * \n * @param base \n * @param f \n */\nexport function createScalarFunctionCode(base: ValueFunction<number>, f: (arg: number) => number): ValueFunction<number> {\n    return (ctx: Record<string, AnyValue>) => {\n        const x = base(ctx)\n        const result = f(base(ctx));\n        tracing(() => `function ${f} of ${x} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param base \n */\nexport function createTransposeCode(base: ValueFunction<Matrix>): ValueFunction<Matrix> {\n    return (ctx: Record<string, AnyValue>) => {\n        const x = base(ctx)\n        const result = x.transpose();\n        tracing(() => `transpose ${x} =${result}`);\n        return result;\n    }\n}\n\n/**\n * \n * @param base \n */\nexport function createQRotCode(base: ValueFunction<Matrix>): ValueFunction<Quaternion> {\n    return (ctx: Record<string, AnyValue>) => {\n        const x = base(ctx)\n        const result = x.qrot();\n        tracing(() => `qRot ${x} =${result}`);\n        return result;\n    }\n}\n\n/**\n * \n * @param base \n */\nexport function createTrCode(base: ValueFunction<Matrix>): ValueFunction<number> {\n    return (ctx: Record<string, AnyValue>) => {\n        const x = base(ctx)\n        const result = x.trace();\n        tracing(() => `trace ${x} =${result}`);\n        return result;\n    }\n}\n\n/**\n * \n * @param base \n */\nexport function createNormalCode(base: ValueFunction<Matrix>): ValueFunction<Matrix> {\n    return (ctx: Record<string, AnyValue>) => {\n        const v = base(ctx);\n        const result = v.norma();\n        tracing(() => `norma ${v} =${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param base \n */\nexport function createCylCode(base: ValueFunction<Matrix>): ValueFunction<Matrix> {\n    return (ctx: Record<string, AnyValue>) => {\n        const v = base(ctx);\n        const result = v.cyl();\n        tracing(() => `cyl ${v} =${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param base \n */\nexport function createCyl1Code(base: ValueFunction<Matrix>): ValueFunction<Matrix> {\n    return (ctx: Record<string, AnyValue>) => {\n        const v = base(ctx);\n        const result = v.cyl1();\n        tracing(() => `cyl1 ${v} =${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param base \n */\nexport function createSphereCode(base: ValueFunction<Matrix>): ValueFunction<Matrix> {\n    return (ctx: Record<string, AnyValue>) => {\n        const v = base(ctx);\n        const result = v.sphere();\n        tracing(() => `sphere ${v} =${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param base \n */\nexport function createSphere1Code(base: ValueFunction<Matrix>): ValueFunction<Matrix> {\n    return (ctx: Record<string, AnyValue>) => {\n        const v = base(ctx);\n        const result = v.sphere1();\n        tracing(() => `sphere1 ${v} =${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param base \n */\nexport function createScalarInvCode(base: ValueFunction<number>): ValueFunction<number> {\n    return (ctx: Record<string, AnyValue>) => {\n        const v = base(ctx);\n        const result = 1 / v;\n        tracing(() => `inverse ${v} =${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param base \n */\nexport function createQuaternionInvCode(base: ValueFunction<Quaternion>): ValueFunction<Quaternion> {\n    return (ctx: Record<string, AnyValue>) => {\n        const v = base(ctx);\n        const result = Quaternion.Inverse(v);\n        tracing(() => `inverse ${v} =${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param base \n */\nexport function createMatrixInvCode(base: ValueFunction<Matrix>): ValueFunction<Matrix> {\n    return (ctx: Record<string, AnyValue>) => {\n        const v = base(ctx);\n        const result = v.inverse();\n        tracing(() => `inverse ${v} =${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param base \n */\nexport function createDetCode(base: ValueFunction<Matrix>): ValueFunction<number> {\n    return (ctx: Record<string, AnyValue>) => {\n        const v = base(ctx);\n        const result = v.det();\n        tracing(() => `det ${v} =${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param base \n */\nexport function createMinCode(base: ValueFunction<Matrix>): ValueFunction<number> {\n    return (ctx: Record<string, AnyValue>) => {\n        const v = base(ctx);\n        const result = v.min();\n        tracing(() => `min ${v} =${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param base \n */\nexport function createMaxCode(base: ValueFunction<Matrix>): ValueFunction<number> {\n    return (ctx: Record<string, AnyValue>) => {\n        const v = base(ctx);\n        const result = v.max();\n        tracing(() => `max ${v} =${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n * @param b \n */\nexport function createMulSSCode(a: ValueFunction<number>, b: ValueFunction<number>): ValueFunction<number> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const bv = b(ctx);\n        const result = av * bv;\n        tracing(() => `mul ${av} * ${bv} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n * @param b \n */\nexport function createMulSQCode(a: ValueFunction<number>, b: ValueFunction<Quaternion>): ValueFunction<Quaternion> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const bv = b(ctx);\n        const result = bv.scale(av);\n        tracing(() => `mul ${av} * ${bv} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n * @param b \n */\nexport function createMulSMCode(a: ValueFunction<number>, b: ValueFunction<Matrix>): ValueFunction<Matrix> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const bv = b(ctx);\n        const result = bv.scale(av);\n        tracing(() => `mul ${av} * ${bv} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n * @param b \n */\nexport function createMulQQCode(a: ValueFunction<Quaternion>, b: ValueFunction<Quaternion>): ValueFunction<Quaternion> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const bv = b(ctx);\n        const result = av.multiply(bv);\n        tracing(() => `mul ${av} * ${bv} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n * @param b \n */\nexport function createScalarMulCode(a: ValueFunction<Matrix>, b: ValueFunction<Matrix>): ValueFunction<number> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const bv = b(ctx);\n        const result = av.dot(bv);\n        tracing(() => `mul ${av} * ${bv} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n * @param b \n */\nexport function createMulMMCode(a: ValueFunction<Matrix>, b: ValueFunction<Matrix>): ValueFunction<Matrix> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const bv = b(ctx);\n        const result = av.multiply(bv);\n        tracing(() => `mul ${av} * ${bv} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n * @param b \n */\nexport function createDivSSCode(a: ValueFunction<number>, b: ValueFunction<number>): ValueFunction<number> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const bv = b(ctx);\n        const result = av / bv;\n        tracing(() => `div ${av} / ${bv} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n * @param b \n */\nexport function createDivSQCode(a: ValueFunction<number>, b: ValueFunction<Quaternion>): ValueFunction<Quaternion> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const bv = b(ctx);\n        const result = Quaternion.Inverse(bv).scale(av)\n        tracing(() => `div ${av} / ${bv} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n * @param b \n */\nexport function createDivQSCode(a: ValueFunction<Quaternion>, b: ValueFunction<number>): ValueFunction<Quaternion> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const bv = b(ctx);\n        const result = av.scale(1 / bv);\n        tracing(() => `div ${av} / ${bv} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n * @param b \n */\nexport function createDivQQCode(a: ValueFunction<Quaternion>, b: ValueFunction<Quaternion>): ValueFunction<Quaternion> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const bv = b(ctx);\n        const result = av.multiply(Quaternion.Inverse(bv));\n        tracing(() => `div ${av} / ${bv} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n * @param b \n */\nexport function createDivMSCode(a: ValueFunction<Matrix>, b: ValueFunction<number>): ValueFunction<Matrix> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const bv = b(ctx);\n        const result = av.divide(bv);\n        tracing(() => `div ${av} / ${bv} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n * @param b \n */\nexport function createDivMMCode(a: ValueFunction<Matrix>, b: ValueFunction<Matrix>): ValueFunction<Matrix> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const bv = b(ctx);\n        const result = av.multiply(bv.inverse());\n        tracing(() => `div ${av} / ${bv} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n * @param b \n */\nexport function createAddSSCode(a: ValueFunction<number>, b: ValueFunction<number>): ValueFunction<number> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const bv = b(ctx);\n        const result = av + bv;\n        tracing(() => `add ${av} + ${bv} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n * @param b \n */\nexport function createAddSQCode(a: ValueFunction<number>, b: ValueFunction<Quaternion>): ValueFunction<Quaternion> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const bv = b(ctx);\n        const result = bv.add(Quaternion.Identity().scale(av));\n        tracing(() => `add ${av} + ${bv} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n * @param b \n */\nexport function createAddQQCode(a: ValueFunction<Quaternion>, b: ValueFunction<Quaternion>): ValueFunction<Quaternion> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const bv = b(ctx);\n        const result = av.add(bv);\n        tracing(() => `add ${av} + ${bv} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n * @param b \n */\nexport function createAddMMCode(a: ValueFunction<Matrix>, b: ValueFunction<Matrix>): ValueFunction<Matrix> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const bv = b(ctx);\n        const result = av.add(bv);\n        tracing(() => `add ${av} + ${bv} = ${result}`);\n        return result;\n    };\n}\n\n\n/**\n * \n * @param a \n * @param b \n */\nexport function createSubSSCode(a: ValueFunction<number>, b: ValueFunction<number>): ValueFunction<number> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const bv = b(ctx);\n        const result = av - bv;\n        tracing(() => `sub ${av} - ${bv} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n * @param b \n */\nexport function createSubSQCode(a: ValueFunction<number>, b: ValueFunction<Quaternion>): ValueFunction<Quaternion> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const bv = b(ctx);\n        const result = Quaternion.Identity().scale(av).subtract(bv);\n        tracing(() => `sub ${av} - ${bv} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n * @param b \n */\nexport function createSubQSCode(a: ValueFunction<Quaternion>, b: ValueFunction<number>): ValueFunction<Quaternion> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const bv = b(ctx);\n        const result = av.subtract(Quaternion.Identity().scale(bv));\n        tracing(() => `sub ${av} - ${bv} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n * @param b \n */\nexport function createSubQQCode(a: ValueFunction<Quaternion>, b: ValueFunction<Quaternion>): ValueFunction<Quaternion> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const bv = b(ctx);\n        const result = av.subtract(bv);\n        tracing(() => `sub ${av} - ${bv} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n * @param b \n */\nexport function createSubMMCode(a: ValueFunction<Matrix>, b: ValueFunction<Matrix>): ValueFunction<Matrix> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const bv = b(ctx);\n        const result = av.subtract(bv);\n        tracing(() => `sub ${av} - ${bv} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n */\nexport function createModScalarCode(a: ValueFunction<number>): ValueFunction<number> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const result = Math.abs(av);\n        tracing(() => `module ${av} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n */\nexport function createModQuaternionCode(a: ValueFunction<Quaternion>): ValueFunction<number> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const result = av.length();\n        tracing(() => `module ${av} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n */\nexport function createModVectorCode(a: ValueFunction<Matrix>): ValueFunction<number> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const result = av.module();\n        tracing(() => `module ${av} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n * @param b \n */\nexport function createConcatSS(a: ValueFunction<number>, b: ValueFunction<number>): ValueFunction<Matrix> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const bv = b(ctx);\n        const result = vector(av, bv);\n        tracing(() => `concat ${av}, ${bv} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n * @param b \n */\nexport function createInsertCode(a: ValueFunction<number>, b: ValueFunction<Matrix>): ValueFunction<Matrix> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const bv = b(ctx);\n        const result = bv.insertAt(0, av);\n        tracing(() => `concat ${av}, ${bv} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n * @param b \n */\nexport function createAppendScalarCode(a: ValueFunction<Matrix>, b: ValueFunction<number>): ValueFunction<Matrix> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const bv = b(ctx);\n        const result = av.insertAt(av.rows, bv);\n        tracing(() => `concat ${av}, ${bv} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n * @param b \n */\nexport function createAppendCode(a: ValueFunction<Matrix>, b: ValueFunction<Matrix>): ValueFunction<Matrix> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const bv = b(ctx);\n        const result = av.append(bv);\n        tracing(() => `concat ${av}, ${bv} = ${result}`);\n        return result;\n    };\n}\n\n/**\n * \n * @param a \n * @param rows \n * @param cols \n */\nexport function createResizeCode(a: ValueFunction<Matrix>, rows: number, cols: number): ValueFunction<Matrix> {\n    return (ctx: Record<string, AnyValue>) => {\n        const av = a(ctx);\n        const result = av.resize(rows, cols);\n        tracing(() => `resive ${av} by ${rows}x${cols} = ${result}`);\n        return result;\n    };\n}","\nimport { ASTNode, ASTNodeType, baseVectorId, deepFirstFlatMap, kroneckerId, parse, TreeNode } from \"./leibniz-parser\";\nimport _ from 'lodash';\nimport {\n    BodyStructure, Errors, SystemDefinition, SystemErrors, CompilerResult,\n    SystemStructure, BodyStatus, BodyStructurePR, CurrentSysDefVersion\n} from \"./leibniz-defs\";\nimport { AnyValue } from \"./leibniz-tensor\";\nimport {\n    ValueCode, ConstantCode,\n    createCodeGenContext, expressionCodeGen,\n    DefaultScalarCode,\n    ValueTypeCode,\n    isVectorCode,\n    isQuaternionCode,\n    errorByCode,\n    CodeGenContext,\n    isScalarCode,\n    isMatrixCode,\n    numberCode,\n    vector0Code,\n    DefaultQuaternionCode,\n    refScalarCode,\n    refVectorCode,\n    refQuaternionCode,\n    refMatrixCode,\n    matrix0Code,\n    FunctionKeywords\n} from \"./leibnitz-codegen\";\nimport { Validator } from \"jsonschema\";\n\nconst VersionPattern = /^(\\d*)\\.(\\d*)$/;\n\nconst SystemDefinitionSchema = {\n    type: 'object',\n    properties: {\n        version: { type: 'string', pattern: '^\\\\d*\\\\.\\\\d*$' },\n        bodies: {\n            type: 'array',\n            items: {\n                type: 'object',\n                properties: {\n                    position: { type: 'string' },\n                    rotation: { type: 'string' }\n                },\n                required: ['position']\n            }\n        },\n        funcs: {\n            type: 'object',\n            additionalProperties: { type: 'string' }\n        },\n        initialStatus: {\n            type: 'object',\n            additionalProperties: { type: 'string' }\n        },\n        transition: {\n            type: 'object',\n            additionalProperties: { type: 'string' }\n        }\n    },\n    required: ['version', 'bodies', 'funcs', 'initialStatus', 'transition']\n};\n\nexport const keywords = _.concat(FunctionKeywords, _.keys(ConstantCode), 'dt');\n\nexport type DefinitionErrors = Record<string, Errors>;\n\ntype SystemParsingResult = {\n    asts: SystemStructure<TreeNode<ASTNode>>;\n    errors: SystemErrors;\n};\n\ntype SystemDeps = SystemStructure<string[]>;\n\ntype SymbolTable = Record<string, ValueCode>;\n\n/**\n * \n * @param data \n * @param mapper \n */\nexport function mapBodyPR<SP, SR, TP, TR>(\n    data: BodyStructurePR<SP, SR>,\n    mapperP: (arg0: SP) => TP,\n    mapperR: (arg0: SR) => TR): BodyStructurePR<TP, TR> {\n    const position = mapperP(data.position);\n    const rotation = data.rotation ? mapperR(data.rotation) : undefined;\n    return { position, rotation };\n}\n\n/**\n * \n * @param data \n * @param mapper \n */\nexport function mapBody<T, R>(\n    data: BodyStructure<T>,\n    mapper: (arg0: T) => R): BodyStructure<R> {\n    const position = mapper(data.position);\n    const rotation = data.rotation ? mapper(data.rotation) : undefined;\n    return { position, rotation };\n}\n\n/**\n * \n * @param data \n * @param mapper \n */\nexport function mapBodies<T, R>(\n    data: BodyStructure<T>[],\n    mapper: (arg0: T) => R): BodyStructure<R>[] {\n    const bodies = data.map(body => mapBody(body, mapper));\n    return bodies;\n}\n\n/**\n * \n * @param data \n * @param mapper \n */\nexport function mapBodiesPR<SP, SR, TP, TR>(\n    data: BodyStructurePR<SP, SR>[],\n    mapperP: (arg0: SP) => TP,\n    mapperR: (arg0: SR) => TR): BodyStructurePR<TP, TR>[] {\n    const bodies = data.map(body => mapBodyPR(body, mapperP, mapperR));\n    return bodies;\n}\n\n/**\n * Returns the mapped system structure\n * @param sys the original system structure\n * @param mapper the mapper function\n */\nfunction mapSystem<T, R>(sys: SystemStructure<T>, mapper: (arg0: T) => R): SystemStructure<R> {\n    const bodies = mapBodies(sys.bodies, mapper);\n    const funcs = _.mapValues(sys.funcs, mapper);\n    const initialStatus = _.mapValues(sys.initialStatus, mapper);\n    const transition = _.mapValues(sys.transition, mapper);\n    return { bodies, funcs, initialStatus, transition };\n}\n\n/**\n * Returns the zipped system structure combining the nodes from two system structures\n * @param t the first structure\n * @param u  the second structure\n */\nfunction zipSystemStructure<T, U>(t: SystemStructure<T>, u: SystemStructure<U>): SystemStructure<[T | undefined, U | undefined]> {\n    function zip(t: Record<string, T>, u: Record<string, U>): Record<string, [T | undefined, U | undefined]> {\n        const result = _([u, t])\n            .flatMap(_.keys)\n            .map(key => {\n                const value: [T | undefined, U | undefined] = [t[key], u[key]];\n                return [key, value] as [string, [T | undefined, U | undefined]];\n            })\n            .fromPairs()\n            .value();\n        return result;\n    }\n    const bodies = _.zip(t.bodies, u.bodies).map(([t1, u1]) => {\n        const position: [T | undefined, U | undefined] = [t1?.position, u1?.position];\n        const rotation: [T | undefined, U | undefined] | undefined =\n            t1?.rotation !== undefined || u1?.rotation !== undefined ?\n                [t1?.rotation, u1?.rotation] :\n                undefined\n        return { position, rotation };\n    });\n    const funcs = zip(t.funcs, u.funcs);\n    const initialStatus = zip(t.initialStatus, u.initialStatus);\n    const transition = zip(t.transition, u.transition);\n    return { bodies, funcs, initialStatus, transition };\n}\n\n/**\n* Returns the parsing result of a system definitions with the AST and errors\n* @param sys the system definition\n*/\nexport function parseSystemDefs(sys: SystemDefinition): SystemParsingResult {\n    const parsed = mapSystem(sys, parse);\n    const asts = mapSystem(parsed, node => node.ast);\n    const errors = mapSystem(parsed, node => node.errors);\n    return { asts, errors };\n}\n\n/**\n * \n * @param keys \n */\nfunction idOnly(keys: string[]): string[] {\n    return keys.filter(key =>\n        !(keywords.indexOf(key) >= 0\n            || kroneckerId(key) !== undefined\n            || baseVectorId(key) !== undefined)\n    )\n}\n\n/**\n * Returns the list of dependencies from an AST\n * @param ast the AST\n */\nexport function extractDependencies(ast: TreeNode<ASTNode>): string[] {\n    const result = deepFirstFlatMap(ast, node => node)\n        .map(node => {\n            switch (node.type) {\n                case ASTNodeType.Id:\n                    return node.id;\n                default:\n                    return '';\n            }\n        })\n        .filter(dep => !!dep)\n        || [];\n    return idOnly(result);\n}\n\n/**\n * Returns the system dependencies\n * @param sys the system parsing result\n */\nexport function dependencies(sys: SystemParsingResult): SystemDeps {\n    return mapSystem(sys.asts, extractDependencies);\n}\n\n/**\n * \n * @param sys \n */\nfunction symbolKeys(sys: SystemDeps) {\n    return _.uniq(_.concat(_.keys(sys.funcs), _.keys(sys.initialStatus)));\n}\n\n/**\n * Returns the system errors concatenation\n * @param a the first system errors\n * @param b the second system errors\n */\nfunction concatErrors(a: SystemErrors, b: SystemErrors): SystemErrors {\n    const zipped = zipSystemStructure(a, b);\n    const result = mapSystem(zipped, ([a, b]) => {\n        return _.concat(a || [], b || []);\n    });\n    return result;\n}\n\n/**\n * Returns the undefined dependency errors\n * @param deps the dependencies\n */\nexport function undefinedDependencyErrors(deps: SystemDeps): SystemErrors {\n    const keys = symbolKeys(deps);\n\n    function depErrors(deps: string[]) {\n        return _.difference(deps, keys).map(id => `${id} is not defined`);\n    }\n\n    return mapSystem(deps, depErrors);\n}\n\n/**\n * Returns the errors for start transition\n * @param sys the system parsing result\n */\nexport function transitionErrors(sys: SystemParsingResult): DefinitionErrors {\n    const statusKeys = _.keys(sys.asts.initialStatus);\n    const transitionKeys = _.keys(sys.asts.transition);\n    const errorsKeys = _.difference(transitionKeys, statusKeys);\n    const transition = _.mapValues(sys.asts.transition, (value, key) => {\n        return errorsKeys.indexOf(key) >= 0 ? [`${key} is not an initial status`] : [];\n    });\n    return transition;\n}\n\n/**\n * \n * @param map \n */\nexport function closure(map: Record<string, string[]>): Record<string, string[]> {\n    const allValues = _(map).toPairs().flatMap(([key, names]) => names).value();\n    const names = _.uniq(_.concat(_.keys(map), allValues));\n    const n = names.length;\n    // Creates the adjacent matrix\n    const closure = _.range(0, n).map(() => _.range(0, n).map(() => false));\n    for (var ii = 0; ii < n; ii++) {\n        const i = ii;\n        const deps = map[names[i]] || [];\n        deps.forEach(name => {\n            closure[i][names.indexOf(name)] = true;\n        });\n    }\n    // Computes closure with warshall's algorithm\n    for (var k = 0; k < n; ++k) {\n        for (var i = 0; i < n; ++i) {\n            for (var j = 0; j < n; ++j) {\n                if (closure[i][k] && closure[k][j]) {\n                    closure[i][j] = true;\n                }\n            }\n        }\n    }\n    const result = _(_.range(0, n)).map(i => {\n        const to = _(_.range(0, n))\n            .map(j => {\n                return { to: names[j], value: closure[i][j] };\n            })\n            .filter({ value: true })\n            .map('to')\n            .value()\n        return [names[i], to];\n    })\n        .fromPairs()\n        .value();\n    return result;\n}\n\n/**\n * \n * @param args \n * @param reducer \n * @param indentity \n */\nfunction concatValues<T>(...args: Record<string, T[]>[]): Record<string, T[]> {\n    const keys = _(args).flatMap(i => _.keys(i));\n    const x = keys.map(key => {\n        const values = _(args).flatMap(m => m[key] || []).value()\n        return [key, values] as [string, T[]];\n    })\n        .fromPairs()\n        .value();\n    return x;\n}\n\n/**\n * \n * @param deps \n */\nexport function circularErrors(deps: SystemDeps): SystemErrors {\n    function circRef(deps: Record<string, string[]>): string[] {\n        const close = closure(deps);\n        const result = _(close)\n            .toPairs()\n            .filter(([k, v]) => v.indexOf(k) >= 0)\n            .map(x => x[0])\n            .value();\n        return result;\n    }\n\n    function circErrors(refs: string[]): Record<string, string[]> {\n        return _(refs)\n            .map(id => [id, [`${id} is a circular reference`]] as [string, string[]])\n            .fromPairs()\n            .value();\n    }\n\n    const circ1 = circRef(concatValues(deps.funcs, deps.initialStatus));\n    const initialStatus = circErrors(_.intersection(circ1, _.keys(deps.initialStatus)));\n    const funcs = circErrors(_.intersection(circ1, _.keys(deps.funcs)));\n    return { bodies: [], initialStatus, funcs, transition: {} };\n}\n\n/**\n * \n * @param deps \n */\nexport function funcStatusErrors(deps: SystemDeps): DefinitionErrors {\n    const funcsDefs = _.intersection(_.keys(deps.funcs), _.keys(deps.initialStatus));\n    const funcs = _(funcsDefs)\n        .map(id => [id, [`${id} is a status variable`]])\n        .fromPairs()\n        .value();\n    return funcs;\n}\n\n/**\n * Returns the ordered symbols of a DAG tree\n * Each symbol appears before any other reference to it\n * @param deps\n */\nexport function orderedDependencies(deps: Record<string, string[]>): string[] {\n\n    function deepFirstTraverse(node: string, acc: string[]): string[] {\n        if (acc.indexOf(node) >= 0) {\n            return acc;\n        } else {\n            const deps1 = deps[node];\n            if (deps1) {\n                const acc1 = _(deps1).reduce((a, n) => deepFirstTraverse(n, a), acc);\n                return _.concat(acc1, node);\n            } else {\n                return _.concat(acc, node);\n            }\n        }\n    }\n\n    const dagKeys = _.keys(deps);\n    const orderedKeys = _.reduce(dagKeys,\n        (acc, node) => deepFirstTraverse(node, acc),\n        [] as string[]);\n    return orderedKeys;\n}\n\ninterface CodeGenResult {\n    table: SymbolTable;\n    errors: SystemErrors;\n}\n\n/**\n * \n * @param ast \n */\n// function dumpAst(ast: TreeNode<ASTNode>): string {\n//     function node(n: ASTNode): string {\n//         switch (n.type) {\n//             case ASTNodeType.End:\n//                 return 'EOM';\n//             case ASTNodeType.Id:\n//                 return n.id;\n//             case ASTNodeType.Number:\n//                 return n.value;\n//             case ASTNodeType.Sym:\n//                 return n.symbol;\n//             case ASTNodeType.Rule:\n//                 return `<${n.rule}>`;\n//         }\n//     }\n\n//     function dump(ast: TreeNode<ASTNode>): string[] {\n//         const ch = _.flatMap(ast.children, dump);\n//         return _.concat([node(ast.node)], ch);\n//     }\n\n//     return dump(ast).join('\\n');\n// }\n\n\n/**\n * Returns the semantic analysis of an ast map related to a variable resolver.\n * It check for missing definitions, cycle references, semantic source code errors.\n * @param astsMap the asts map\n * @param resolver the variable resolver \n */\nfunction codeGen(astsMap: Record<string, TreeNode<ASTNode>>, resolver: Record<string, ValueCode>) {\n    const symbolDeps = _.mapValues(astsMap, extractDependencies);\n    // extracts the keys of status + functions\n    const symbolKeys = _.keys(symbolDeps);\n    const clos = closure(symbolDeps);\n    // Creates the cycled symbols\n    const loopKeys = _(clos)\n        .toPairs()\n        .filter(([k, v]) => v.indexOf(k) >= 0)\n        .map(([k, v]) => k)\n        .value();\n    // Creates the acycled symbols\n    const dagKeys = _.difference(symbolKeys, loopKeys);\n    // Creates the acycled dependencies\n    const dagDeps = _(dagKeys)\n        .map(k => [k, symbolDeps[k]] as [string, string[]])\n        .fromPairs()\n        .value();\n    // creates the order of resolution of symbols\n    const orderedKeys = orderedDependencies(dagDeps);\n\n    // generates the symbol table for the cycle symbols (seed for code generation)\n    const loopSymbolTable: SymbolTable = _(loopKeys).map(key => {\n        return [key, numberCode(0)] as [string, ValueCode];\n    })\n        .fromPairs()\n        .value();\n    const seedTable = _.assign({}, loopSymbolTable, resolver);\n\n    // generates the errors of cycle symbols (seed of code generation)\n    const loopErrors = _(loopKeys).map(key => {\n        return [key, [`\"${key}\" is a cycle reference`]] as [string, string[]];\n    })\n        .fromPairs()\n        .value();\n\n    // add the missing references errors\n    const allRef = _(symbolDeps).values().flatten().uniq().value();\n    const missingRef = _.difference(allRef, symbolKeys, _.keys(resolver));\n    const missingRefErrors = _(symbolDeps)\n        .mapValues((deps, key) =>\n            deps.filter(d => missingRef.indexOf(d) >= 0).map(id => `\"${id}\" is not defined`)\n        )\n        .value();\n    const seedErrors = concatValues(loopErrors, missingRefErrors);\n\n    // generates the symbol table and error ordered by symbol resolution\n    const result = _(orderedKeys).reduce((res, key) => {\n        const { table, errors } = res;\n        if (table[key] !== undefined) {\n            return res;\n        }\n        const ast = astsMap[key];\n        const ttable = _.clone(table);\n        if (ast !== undefined) {\n            const ctx = createCodeGenContext(table);\n            const ctx1 = expressionCodeGen(ctx, ast);\n            ttable[key] = ctx1.typeCode;\n            const terrors = _.clone(errors);\n            terrors[key] = _.concat(terrors[key] ?? [], ctx1.errors);\n            return { table: ttable, errors: terrors };\n        } else {\n            ttable[key] = DefaultScalarCode;\n            return { table: ttable, errors };\n        }\n    }, {\n        table: seedTable,\n        errors: seedErrors\n    });\n    return result;\n}\n\n/**\n * Returns the sematic analysis of functions and initial values of\n * status variable and related errors.\n * It checks for missing definition, circular reference,\n * inconsistencies between operators and type of expressions.\n * @param sys \n */\nexport function statusCodeGen(sys: SystemParsingResult): CodeGenResult {\n    const astMaps = _.fromPairs(_.concat(\n        _.toPairs(sys.asts.funcs),\n        _.toPairs(sys.asts.initialStatus)));\n    const { table, errors } = codeGen(astMaps, { dt: numberCode(0) });\n    // convert the errors to system errors\n    const sysErrors: SystemErrors = {\n        bodies: [],\n        funcs: _(sys.asts.funcs).mapValues((v, k) => errors[k] ?? []).value(),\n        initialStatus: _(sys.asts.initialStatus).mapValues((v, k) => errors[k] ?? []).value(),\n        transition: {}\n    }\n    // extract the symbol table for status only\n    const statusTable = _(sys.asts.initialStatus)\n        .mapValues((v, k) => table[k])\n        .value();\n\n    return { table: statusTable, errors: sysErrors };\n}\n\n/**\n * \n * @param ctx \n * @param node \n */\nfunction nodeCodeGen(ctx: CodeGenContext, node: TreeNode<ASTNode>) {\n    const result = expressionCodeGen(ctx, node);\n    // Check for missng references\n    const deps = extractDependencies(node);\n    const depErrors = deps\n        .filter(id => ctx.symbol(id) === undefined)\n        .map(id => `\"${id}\" is not defined`);\n    return depErrors.length > 0 ? result.addErrors(depErrors) : result;\n}\n\nconst DefaultPosition = vector0Code(3);\nconst DefaultRotation = DefaultQuaternionCode;\n\n/**\n * Returns the sematic analysis of the state of bodies \n * It checks for missing definitions, circular reference,\n * inconsistencies between operators and type of expressions\n * wrong types of body properties (position, rotation).\n * @param sys \n * @param statusTable\n */\nexport function bodiesCodeGen(sys: SystemParsingResult, statusTable: SymbolTable) {\n    // gets the asts map for function resolution\n    const astMaps = sys.asts.funcs;\n\n    // create the status variable resolver\n    const varsTable = _(statusTable)\n        .mapValues((v, k) => {\n            switch (v.type) {\n                case ValueTypeCode.Scalar:\n                    return refScalarCode(k);\n                case ValueTypeCode.Quaternion:\n                    return refQuaternionCode(k);\n                case ValueTypeCode.Vector:\n                    return refVectorCode(k, v.rows);\n                case ValueTypeCode.Matrix:\n                    return refMatrixCode(k, v.rows, v.cols);\n            }\n        })\n        .value();\n    const varsTable1 = _.defaults({ dt: numberCode(0) }, varsTable);\n\n    // analyzes functions\n    const { table } = codeGen(astMaps, varsTable1);\n    const ctx = createCodeGenContext(table);\n\n    // generate code for bodies status\n    const bodiesCodeCtx = mapBodiesPR(sys.asts.bodies,\n        position => {\n            const posCodeCtx = nodeCodeGen(ctx, position);\n            const { typeCode: posTypeCode } = posCodeCtx;\n            const posCodeCtx1 = isVectorCode(posTypeCode) && posTypeCode.rows === 3 ?\n                posCodeCtx :\n                posCodeCtx\n                    .withTypeCode(DefaultPosition)\n                    .addErrors(errorByCode('vector3 expected', posTypeCode));\n            return posCodeCtx1;\n        },\n        rotation => {\n            const rotCodeCtx = nodeCodeGen(ctx, rotation);\n            const rotCodeCtx1 = isQuaternionCode(rotCodeCtx.typeCode) ?\n                rotCodeCtx :\n                rotCodeCtx\n                    .withTypeCode(DefaultRotation)\n                    .addErrors(errorByCode('quaternion expected', rotCodeCtx.typeCode));\n            return rotCodeCtx1;\n        });\n    const code = mapBodiesPR(\n        bodiesCodeCtx,\n        ctx => {\n            if (!isVectorCode(ctx.typeCode)) {\n                throw new Error('Worng type');\n            }\n            return ctx.typeCode\n        },\n        ctx => {\n            if (!isQuaternionCode(ctx.typeCode)) {\n                throw new Error('Worng type');\n            }\n            return ctx.typeCode\n        },\n    );\n\n    const bodiesErrors = mapBodies(bodiesCodeCtx, ctx => ctx.errors);\n\n    const sysErrors: SystemErrors = {\n        bodies: bodiesErrors,\n        funcs: {},\n        initialStatus: {},\n        transition: {}\n    }\n    return { code, errors: sysErrors };\n}\n\n/**\n * Returns the sematic analysis of state transitions.\n * It checks for missing definitions,\n * inconsistencies between operators and type of expressions\n * inconsistency with state definition (type and dimensins)\n * @param sys \n * @param statusTable\n */\nexport function transitionCodeGen(sys: SystemParsingResult, statusTable: SymbolTable) {\n    // gets the asts map for function resolution\n    const astMaps = sys.asts.funcs;\n\n    // create the status variable resolver\n    const varsTable = _(statusTable)\n        .mapValues((v, k) => {\n            switch (v.type) {\n                case ValueTypeCode.Scalar:\n                    return refScalarCode(k);\n                case ValueTypeCode.Quaternion:\n                    return refQuaternionCode(k);\n                case ValueTypeCode.Vector:\n                    return refVectorCode(k, v.rows);\n                case ValueTypeCode.Matrix:\n                    return refMatrixCode(k, v.rows, v.cols);\n            }\n        })\n        .value();\n    const varsTable1 = _.defaults({ dt: refScalarCode('dt') }, varsTable);\n\n    // analyzes functions\n    const { table } = codeGen(astMaps, varsTable1);\n    const ctx = createCodeGenContext(table);\n\n    // generate code for transition status\n    const ctxMap = _(sys.asts.transition).mapValues((ast, key) => {\n        const ctx1 = nodeCodeGen(ctx, ast);\n        const { typeCode } = ctx1;\n        const st = statusTable[key];\n        if (!st) {\n            return ctx1.addErrors([`\"${key}\" is not a status variable`]);\n        }\n        if (isScalarCode(st)) {\n            return isScalarCode(typeCode) ?\n                ctx1 :\n                ctx1.addErrors(errorByCode('scalar expected', typeCode))\n                    .withTypeCode(DefaultScalarCode);\n        }\n        if (isQuaternionCode(st)) {\n            return isQuaternionCode(typeCode) ?\n                ctx1 :\n                ctx1.addErrors(errorByCode('quaternion expected', typeCode))\n                    .withTypeCode(DefaultQuaternionCode);\n        }\n        if (isVectorCode(st)) {\n            return isVectorCode(typeCode) && typeCode.rows === st.rows ?\n                ctx1 :\n                ctx1.addErrors(errorByCode(`vector${st.rows} expected`, typeCode))\n                    .withTypeCode(vector0Code(st.rows));\n        }\n        if (isMatrixCode(st)) {\n            return isMatrixCode(typeCode) && typeCode.rows === st.rows && typeCode.cols === st.cols ?\n                ctx1 :\n                ctx1.addErrors(errorByCode(`matrix${st.rows}x${st.cols} expected`, typeCode))\n                    .withTypeCode(matrix0Code(st.rows, st.cols));\n        }\n        throw new Error('unexpected branch');\n    })\n        .value();\n\n    // extracts to errors\n    const sysErrors: SystemErrors = {\n        bodies: [],\n        funcs: {},\n        initialStatus: {},\n        transition: _.mapValues(ctxMap, 'errors')\n    }\n\n    // Filter status variables\n    const code = _(ctxMap)\n        .mapValues('typeCode')\n        .toPairs()\n        .filter(([k, v]) => statusTable[k] !== undefined)\n        .fromPairs()\n        .value();\n\n    return { code, errors: sysErrors };\n}\n\n/**\n * \n */\nexport function validateSystemDefinition(json: any): json is SystemDefinition {\n    new Validator().validate(json, SystemDefinitionSchema, { throwError: true });\n\n    // Current supported version\n    const cpatt = CurrentSysDefVersion.match(VersionPattern);\n    const vpatt = json.version.match(VersionPattern);\n    if ((vpatt === null || cpatt === null\n        || vpatt[1] !== cpatt[1]\n        || parseInt(vpatt[2]) > parseInt(cpatt[2]))) {\n        throw new Error(`version ${json.version} is not compatible with supported version ${CurrentSysDefVersion}`);\n    }\n    return true;\n}\n\n/**\n * @param sys \n */\nexport function compile(sys: SystemDefinition): CompilerResult {\n\n    /** Parsing phase */\n    const parsed = parseSystemDefs(sys);\n    /** Building symbol tables for status */\n    const { table: statusTable, errors: statusErrors } = statusCodeGen(parsed);\n    /** Building symbol tables for bodies */\n    const { code: bodiesTable, errors: bodiesErrors } = bodiesCodeGen(parsed, statusTable);\n    /** Building symbol tables for transition */\n    const { code: transitionTable, errors: transitionErrors } = transitionCodeGen(parsed, statusTable);\n\n    const statusCode = _.mapValues(statusTable, 'code');\n    const bodiesCode = mapBodiesPR(bodiesTable,\n        typeCode => typeCode.code,\n        typeCode => typeCode.code);\n    const transitionCode = _.mapValues(transitionTable, 'code');\n\n    // Linking\n    const initialStatus: () => Record<string, AnyValue> = () => {\n        const ctx = { dt: 0 };\n        return _.mapValues(statusCode, code => code(ctx));\n    };\n    const bodies: (ctx: Record<string, AnyValue>) => BodyStatus[] = ctx => {\n        const ctx1 = _.assign({ dt: 0 }, ctx);\n        return mapBodiesPR(bodiesCode,\n            code => code(ctx1),\n            code => code(ctx1));\n    };\n    const next: (ctx: Record<string, AnyValue>, dt: number) => Record<string, AnyValue> =\n        (ctx, dt) => {\n            const ctx1 = _.assign({ dt }, ctx);\n            const next = _.mapValues(transitionCode, code => code(ctx1));\n            const result = _.defaults(next, ctx);\n            return result;\n        };\n\n    // Aggregates errors\n    const errors = concatErrors(\n        parsed.errors,\n        concatErrors(\n            statusErrors,\n            concatErrors(\n                bodiesErrors,\n                transitionErrors)));\n\n    return {\n        rules: { bodies, initialStatus, next },\n        errors\n    };\n}\n","import React, { Component } from 'react';\nimport { Form, FormGroup, FormControl, Tabs, Tab, Container } from 'react-bootstrap';\nimport { saveAs } from 'file-saver';\nimport { ajax } from 'rxjs/ajax';\nimport { tap } from 'rxjs/operators';\nimport './App.css';\nimport { BabylonScene, SceneMountEvent } from './react/SceneComponent';\nimport { Editor } from './react/Editor';\nimport { ImportFile } from './react/ImportFile';\nimport { OptionPanel } from './react/OptionPanel';\nimport { DumpPanel } from './react/DumpPanel';\nimport { LbNavBar } from './react/LbNavBar';\nimport { LbAlert } from './react/LbAlert';\nimport { CurrentSysDefVersion, SystemDefinition, SystemErrors, SystemRules } from './modules/leibniz-defs';\nimport { CameraType, Leibniz } from './modules/leibniz-renderer';\nimport { compile, validateSystemDefinition } from './modules/leibniz-compiler';\nimport _ from 'lodash';\n\nconst KEY = 'leibniz';\nconst MinDt = 1e-3;\n\nconst DefaultDefinition: SystemDefinition = {\n  version: CurrentSysDefVersion,\n  bodies: [],\n  funcs: {},\n  initialStatus: {},\n  transition: {}\n};\n\ninterface AppState {\n  alertShow: boolean;\n  alertTitle?: string;\n  alertMessage?: string;\n  modalShown: boolean;\n  importModalShown: boolean;\n  maxDt: string;\n  optionShow?: boolean;\n  optionTitle?: string;\n  optionMessage?: string;\n  optionConfirmBtn?: string;\n  optionConfirm?: () => void,\n  defs?: SystemDefinition;\n  rules?: SystemRules;\n  errors?: SystemErrors;\n  leibniz?: Leibniz;\n}\n\nexport class App extends Component<{}, AppState> {\n  private leibniz: Leibniz | undefined;\n\n  /**\n   * \n   * @param props \n   */\n  constructor(props: {}) {\n    super(props);\n\n    this.state = {\n      maxDt: '0.01',\n      alertShow: false,\n      modalShown: false,\n      importModalShown: false,\n    };\n  }\n\n  /**\n   * \n   * @param conf \n   */\n  private processDefs(defs: SystemDefinition, leibniz?: Leibniz) {\n    const leib = leibniz ?? this.state.leibniz;\n    const { rules, errors } = compile(defs);\n    localStorage.setItem(KEY, JSON.stringify(defs));\n\n    if (leib) {\n      leib.rules = rules;\n    }\n    this.setState({ defs, rules, errors });\n  }\n\n  /**\n   * \n   * @param e \n   */\n  private onSceneMount(e: SceneMountEvent) {\n    const leibniz = new Leibniz(e);\n    leibniz.init({\n      cameraType: CameraType.ArcRotate,\n      maxDt: parseFloat(this.state.maxDt)\n    });\n    this.setState({ leibniz });\n    const text = localStorage.getItem(KEY);\n    const defs = text ? JSON.parse(text) : DefaultDefinition;\n    this.processDefs(defs, leibniz);\n  }\n\n  /**\n   * \n   */\n  private onReset() {\n    this.showOptionPanel(\n      'Reset definitions ?',\n      'The definitions will be resetted to default value.',\n      'Reset',\n      () => this.reset()\n    );\n  }\n\n  private onLoad(name: string) {\n    this.showOptionPanel(\n      'Load definitions ' + name + ' ?',\n      'The definitions will be load from ' + name + ' .',\n      'Load',\n      () => this.load(name)\n    );\n  }\n\n  /**\n   * \n   * @param optionTitle \n   * @param optionMessage \n   * @param optionConfirmBtn \n   * @param optionConfirm \n   */\n  private showOptionPanel(optionTitle: string, optionMessage: string, optionConfirmBtn: string, optionConfirm: () => void) {\n    this.setState({\n      optionShow: true,\n      optionTitle,\n      optionMessage,\n      optionConfirmBtn,\n      optionConfirm\n    });\n  }\n\n  /**\n   * \n   */\n  private hideOptionPanel() {\n    this.setState({ optionShow: false });\n  }\n\n  /**\n   * \n   * @param title \n   * @param message \n   */\n  private showAlert(title: string, message: string) {\n    this.setState({\n      alertShow: true,\n      alertTitle: title,\n      alertMessage: message\n    });\n  }\n\n  /**\n   * \n   */\n  private hideAlert() {\n    this.setState({ alertShow: false });\n  }\n\n  /**\n   * \n   */\n  private reset() {\n    this.processDefs(DefaultDefinition);\n    this.hideOptionPanel();\n  }\n\n  /**\n   * \n   * @param name \n   */\n  private load(name: string) {\n    const url = process.env.REACT_APP_BASENAME + '/' + name;\n    ajax.getJSON(url).pipe(\n      tap(\n        json => this.onLoaded(json),\n        ajax => this.onLoadError(ajax)\n      )\n    ).subscribe();\n  }\n\n  /**\n   * \n   * @param json \n   */\n  private onLoaded(json: any) {\n    this.hideOptionPanel();\n    try {\n      if (validateSystemDefinition(json)) {\n        this.processDefs(json);\n      }\n    } catch (ex: any) {\n      this.onError(ex);\n    }\n  }\n\n  private onLoadError(ajax: any) {\n    console.error(ajax);\n    const msg = ajax.xhr.status + ' - ' + ajax.xhr.statusText;\n    console.error(msg);\n    this.showAlert('Error', msg);\n    this.hideOptionPanel();\n  }\n\n  /**\n   * \n   */\n  private showImportPanel() {\n    this.setState({ importModalShown: true });\n  }\n\n  /**\n   * \n   */\n  private hideImportPanel() {\n    this.setState({ importModalShown: false });\n  }\n\n  /**\n   * \n   * @param content \n   */\n  private importFile(content: string) {\n    try {\n      this.hideAlert();\n      this.hideImportPanel();\n      const json = JSON.parse(content);\n      if (validateSystemDefinition(json)) {\n        this.processDefs(json);\n      }\n    } catch (e) {\n      console.error('Error parsing', content);\n      this.onError(e);\n    }\n  }\n\n  /**\n   * \n   * @param e \n   */\n  private onError(e: string) {\n    this.showAlert('Error', 'Error parsing file ' + e);\n    this.hideImportPanel();\n  }\n\n  /**\n   * \n   */\n  private showExportPanel() {\n    this.showOptionPanel(\n      'Export definitions ?',\n      'The definitions will be exported into a local file.',\n      'Export',\n      () => this.exportFile()\n    );\n  }\n\n  /**\n   * \n   * @param value \n   */\n  private setMaxDt(maxDt: string) {\n    this.setState({ maxDt: maxDt });\n    if (this.leibniz) {\n      const dtnum1 = parseFloat(maxDt);\n      this.leibniz.maxDt = Math.max(MinDt, dtnum1);\n    }\n  }\n\n  /**\n   * \n   */\n  private exportFile() {\n    const { defs } = this.state;\n    this.hideOptionPanel();\n    if (defs) {\n      const exporting = _.defaults({ version: CurrentSysDefVersion }, defs);\n      const text = JSON.stringify(exporting, null, 2);\n      const blob = new Blob([text], { type: \"text/plain;charset=utf-8\" });\n      saveAs(blob, \"test.json\");\n    }\n  }\n\n  /**\n   * \n   */\n  render() {\n    const {\n      alertShow, alertTitle, alertMessage,\n      importModalShown,\n      optionShow, optionTitle, optionMessage, optionConfirmBtn, optionConfirm,\n      maxDt, defs, errors, rules\n    } = this.state;\n    return (\n      <Container fluid>\n        <LbNavBar\n          onReset={() => this.onReset()}\n          onLoad={(file) => this.onLoad(file)}\n          onImport={() => this.showImportPanel()}\n          onExport={() => this.showExportPanel()}\n        />\n        <LbAlert isVisible={alertShow}\n          title={alertTitle}\n          message={alertMessage}\n          onClose={() => this.hideAlert()} />\n        <Container>\n          <Tabs id=\"Tab\" defaultActiveKey=\"home\">\n            <Tab eventKey=\"home\" title=\"Home\">\n              <BabylonScene onSceneMount={(ev: any) => this.onSceneMount(ev)}\n                canvasClass=\"graphCanvas\" />\n              <Form inline>\n                <FormGroup controlId=\"formInlineName\">\n                  <Form.Label>Max dt</Form.Label>{' '}\n                  <FormControl type=\"text\" placeholder=\"Max dt\"\n                    onChange={ev => this.setMaxDt(ev.target.value)}\n                    value={maxDt} />\n                </FormGroup>{' '}\n              </Form>\n            </Tab>\n            <Tab eventKey=\"editor\" title=\"Editor\">\n              <Editor defs={defs} errors={errors}\n                onChange={defs => this.processDefs(defs)} />\n            </Tab>\n            <Tab eventKey=\"dump\" title=\"Dump panel\">\n              <DumpPanel rules={rules} />\n            </Tab>\n          </Tabs>\n        </Container>\n        <ImportFile show={importModalShown}\n          onCancel={() => this.hideImportPanel()}\n          onFileRead={file => this.importFile(file as string)}\n          onError={e => this.onError(e)} />\n        <OptionPanel show={!!optionShow}\n          title={optionTitle}\n          message={optionMessage}\n          confirmButton={optionConfirmBtn || ''}\n          onCancel={() => this.hideOptionPanel()}\n          onConfirm={optionConfirm} />\n      </Container>\n    );\n  }\n}\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport { App } from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}